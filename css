

in this some  issue, Uptime Duration is not on and Downtime Duration alos not correct and Downtime Count alos some wrong 
Sr. No	Device IP	Device Name	Device Type	Uptime Duration	Downtime Count	Downtime Duration	Details	Remark
1	10.64.21.80	LACA CR A209 EMERGENCY EXIT DOOR NORTHWEST - 10.64.21.80	CAMERA	0h/0m/0s	1	1h/41m/36s	View History	Device is Offline, needs check.
2	10.64.21.72	LACA CR A303 EMERGENCY EXIT DOOR NORTHWEST - 10.64.21.72	CAMERA	0h/0m/0s	1	1h/41m/35s	View History	Device is Offline, needs check.
3	10.64.21.134	LACA CR A305 GENERAL NORTHEAST - 10.64.21.134	CAMERA	0h/0m/0s	1	1h/41m/35s	View History	Device is Offline, needs check.
4	10.64.21.5	LACA CR B104 EMERGENCY EXIT DOOR SOUTHWEST1 - 10.64.21.5	CAMERA	0h/0m/0s	1	1h/41m/33s	View History	Device is Offline, needs check.
5	10.64.21.203	LACA CR B207 EMERGENCY EXIT DOOR NORTHEAST - 10.64.21.203	CAMERA	0h/0m/0s	1	1h/41m/33s	View History	Device is Offline, needs check.
6	10.64.22.9	LACA CR B304 EMERGENCY EXIT DOOR NORTHEAST - 10.64.22.9	CAMERA	0h/0m/0s	1	1h/41m/33s	View History	Device is Offline, needs check.
7	10.64.23.72	LACA CR E207 EMERGENCY EXIT DOOR NORTHWEST - 10.64.23.72	CAMERA	0h/0m/0s	1	1h/41m/31s	View History	Device is Offline, needs check.
8	10.64.23.76	LACA CR E210 GENERAL NORTH - 10.64.23.76	CAMERA	0h/0m/0s	1	1h/41m/30s	View History	Device is Offline, needs check.
9	10.64.23.141	LACA CR E312 EMERGENCY EXIT DOOR SOUTH - 10.64.23.141	CAMERA	0h/0m/0s	1	1h/41m/32s	View History	Device is Offline, needs check.
10	10.64.20.72	LACA CR E407 GENERAL NORTHWEST - 10.64.20.72	CAMERA	0h/0m/0s	1	1h/41m/32s	View History	Device is Offline, needs check.
11	10.64.21.109	LACA CR A210 PCI NORTHEAST	CAMERA	0h/0m/0s	1	1h/41m/29s	View History	Device is Offline, needs check.
12	10.64.22.74	LACA CR E401 MAIN ENTRANCE DOOR	CAMERA	0h/0m/0s	1	1h/41m/13s	View History	Device is Offline, needs check.
13	10.21.4.66	US.NYC.199 Water St	CONTROLLER	0h/0m/0s	1	1h/41m/41s	View History	Device is Offline, needs check.
14	10.130.36.56	EMEA Server	SERVER	1h/41m/48s	3	0h/0m/0s	View History	Device is Online.
15	10.64.10.50	LACA Server	SERVER	1h/41m/46s	3	0h/0m/0s	View History	Device is Online.
16	10.194.2.190	Archiver Taguig City Philippines	ARCHIVER	1h/29m/6s	2	0h/0m/0s	View History	Device is Online, had 2 downtime events ≥5 min.
17	10.199.8.30	IN-PUN-PODIUM-ISTAR ULTRA-4	CONTROLLER	4d/1h/1m/37s	2	0h/0m/0s	View History	Device is Online, had 2 downtime events ≥5 min.
18	10.194.2.13	APAC_PH_MANILA_ISTAR PRO_01	CONTROLLER	1h/28m/17s	2	0h/0m/0s	View History	Device is Online, had 2 downtime events ≥5 min.
19	10.136.63.236	Archiver Moscow	ARCHIVER	6d/1h/44m/9s	1	0h/0m/0s	View History	Device is Online, had 1 downtime events ≥5 min.
20	10.80.3.61	PA.Panama City. Panel 01	CONTROLLER	25d/38m/10s	1	0h/0m/0s	View History	Device is Online, had 1 downtime events ≥5 min.
21	10.58.118.20	Master Server	SERVER	1h/41m/10s	1	0h/0m/0s	View History	Device is Online, had 1 downtime events ≥5 min.
22	10.58.118.21	NAMER Server	SERVER	1h/41m/10s	1	0h/0m/0s	View History	Device is Online, had 1 downtime events ≥5 min.
23	10.64.21.26	LACA CR S101 BASEMENT S1 TELECOM WAREHOUSE 07 - 10.64.21.26	CAMERA	0h/0m/0s	0	0h/0m/0s	View History	Device is Online.
24	10.64.21.28	LACA CR S102 BASEMENT S1 FIXED ASSETS WAREHOUSE 51 - 10.64.21.28	CAMERA	0h/0m/0s	0	0h/0m/0s	View History	Device is Online.
25	172.21.132.31	LACA CR S201 BASEMENT S2 EUC WAREHOUSE 15 - 172.21.132.31	CAMERA	0h/0m/0s	0	0h/0m/0s	View History	Device is Online.



and view history page duratin is not correct 
Sr.No	Date	Day	Time	Status	Duration
1	7/29/2025	Tuesday	9:48:31 AM	Offline	-
2	7/29/2025	Tuesday	9:48:31 AM	Offline	1h/43m/44s

see below 
Sr.No	Date	Day	Time	Status	Duration
1	7/22/2025	Tuesday	3:42:24 PM	Offline	-
2	7/22/2025	Tuesday	3:42:24 PM	Offline	2h/30m/4s this is wonrg calcuation 
3	7/22/2025	Tuesday	6:12:28 PM	Online	0s  and this require 30m
4	7/23/2025	Wednesday	9:46:17 AM	Offline	-   in thie require more time because 	7/22/2025	Tuesday	6:12:28 PM to 7/23/2025	Wednesday	9:46:17 AM so why it is show empty 
5	7/23/2025	Wednesday	9:46:17 AM	Offline	2d/42m/13s
6	7/25/2025	Friday	10:28:30 AM	Online	0s

read below all code line by line carefully and give me all updates code all code 




let deviceUptimeTimers = {};
let deviceDowntimeTimers = {};

// Utility to turn an IP (or any string) into a safe DOM-ID fragment
function sanitizeId(str) {
  return (str || '').replace(/[^a-zA-Z0-9]/g, '_');
}

function fetchDeviceData() {
  const region = document.getElementById('region').value;
  fetch(`http://localhost/api/regions/details/${region}`)
    .then(r => r.json())
    .then(d => fetchDeviceHistory(d.details))
    .catch(console.error);
}

function fetchDeviceHistory(details) {
  fetch(`http://localhost/api/devices/history`)
    .then(r => r.json())
    .then(historyData => {
      populateDeviceTable(details, historyData);
      window.deviceHistoryData = historyData;
    })
    .catch(console.error);
}

function populateDeviceTable(details, historyData) {
  const tbody = document.querySelector('#device-table tbody');
  tbody.innerHTML = '';

  const devices = [];
  ['cameras','archivers','controllers','servers'].forEach(type => {
    (details[type] || []).forEach(dev => {
      const ip        = dev.ip_address;
      const safe      = sanitizeId(ip);
      const name      = dev[type.slice(0,-1) + 'name'] || 'Unknown';
      const category  = type.slice(0,-1).toUpperCase();
      const rawHist   = historyData[ip] || [];
      const hist      = filterHistoryForDisplay(rawHist, category);
      const lastRaw   = rawHist[rawHist.length-1]?.status || 'Unknown';
      // if last raw Offline but <5min, treat Online
      let status = lastRaw;
      if (lastRaw === 'Offline' && ((Date.now() - new Date(rawHist[rawHist.length-1].timestamp)) / 1000) < 300) {
        status = 'Online';
      }
      const downCount = hist.filter(e => e.status === 'Offline').length;

      devices.push({ ip, safe, name, category, rawHist, hist, status, downCount });
    });
  });

  // sort by ongoing ≥5min offline first, then by downCount desc
  devices.sort((a,b) => {
    const now = Date.now();
    const aLast = a.hist[a.hist.length-1], bLast = b.hist[b.hist.length-1];
    const aOff  = aLast?.status==='Offline' ? (now-new Date(aLast.timestamp))/1000 : 0;
    const bOff  = bLast?.status==='Offline' ? (now-new Date(bLast.timestamp))/1000 : 0;
    if ((aOff>=300) !== (bOff>=300)) return aOff>=300 ? -1 : 1;
    return b.downCount - a.downCount;
  });

  devices.forEach((d,i) => {
    const row = tbody.insertRow();
    row.classList.add(d.status==='Online' ? 'status-online' : 'status-offline');
    row.innerHTML = `
<td>${i+1}</td>
<td><span id="ip-${d.safe}" class="copy-text" onclick="copyToClipboard('ip-${d.safe}')">${d.ip}</span></td>
<td><span id="name-${d.safe}" class="copy-text" onclick="copyToClipboard('name-${d.safe}')">${d.name}</span></td>
<td>${d.category}</td>
<td id="uptime-${d.safe}">0h/0m/0s</td>
<td id="downtime-count-${d.safe}">${d.downCount}</td>
<td id="downtime-${d.safe}">0h/0m/0s</td>
<td><button class="history-btn" onclick="openDeviceHistory('${d.ip}','${d.name}','${d.category}')">View History</button></td>
<td id="remark-${d.safe}">–</td>
`;
    if (d.status === 'Online') startUptime(d.ip, d.hist);
    else startDowntime(d.ip, d.hist);

    updateRemarks(d.ip, d.hist, d.status, d.downCount);
  });

  filterData();
}

function filterHistoryForDisplay(hist, category) {
  if (category === 'SERVER') return hist.slice();

  const out = [];
  
  let lastOff = null;
  hist.forEach(e => {
    if (e.status === 'Offline') lastOff = e;
    else if (e.status === 'Online' && lastOff) {
      const diff = (new Date(e.timestamp) - new Date(lastOff.timestamp)) / 1000;
      if (diff >= 300) out.push(lastOff, e);
      lastOff = null;
    }
  });

  if (lastOff) {

    const diff = (Date.now() - new Date(lastOff.timestamp)) / 1000;
    if (diff >= 300) out.push(lastOff);
  }
  
  return out.sort((a,b) => new Date(a.timestamp) - new Date(b.timestamp));
}

function startUptime(ip, hist) {
  const safe = sanitizeId(ip);
  clearInterval(deviceDowntimeTimers[safe]);
  const on = hist.filter(e => e.status==='Online').pop();
  if (!on) return;
  const t0 = new Date(on.timestamp).getTime();
  deviceUptimeTimers[safe] = setInterval(() => {
    document.getElementById(`uptime-${safe}`).innerText = formatDuration(Math.floor((Date.now()-t0)/1000));
  }, 1000);
}

function startDowntime(ip, hist) {
  const safe = sanitizeId(ip);
  clearInterval(deviceUptimeTimers[safe]);
  const off = hist.filter(e => e.status==='Offline').pop();
  if (!off) return;
  const t0 = new Date(off.timestamp).getTime();
  deviceDowntimeTimers[safe] = setInterval(() => {
    const secs = Math.floor((Date.now()-t0)/1000);
    document.getElementById(`downtime-${safe}`).innerText = formatDuration(secs);
    document.getElementById(`downtime-count-${safe}`).innerText = hist.filter(e => e.status==='Offline').length;
    updateRemarks(ip, hist, null, null);
  }, 1000);
}

function updateRemarks(ip, hist, forcedStatus, forcedCount) {
  const safe = sanitizeId(ip);
  // Determine status
  let status = forcedStatus;
  if (!status) {
    const last = hist[hist.length-1]?.status || 'Unknown';
    status = last==='Offline' && ((Date.now()-new Date(hist[hist.length-1].timestamp))/1000)<300
      ? 'Online' : last;
  }
  const count = forcedCount ?? hist.filter(e => e.status==='Offline').length;
  const el = document.getElementById(`remark-${safe}`);
  if (!el) return;
  if (status === 'Offline') {
    el.innerText = count>0 ? 'Device is Offline, needs check.' : 'Device is Offline.';
  } else if (status === 'Online') {
    el.innerText = count>0
      ? `Device is Online, had ${count} downtime events ≥5 min.`
      : 'Device is Online.';
  } else {
    el.innerText = 'Device status unknown.';
  }
}

function formatDuration(sec) {
  const d = Math.floor(sec/86400), h = Math.floor((sec%86400)/3600),
        m = Math.floor((sec%3600)/60), s = Math.round(sec%60);
  const parts = [];
  if (d) parts.push(`${d}d`);
  if (h) parts.push(`${h}h`);
  if (m) parts.push(`${m}m`);
  if (s||!parts.length) parts.push(`${s}s`);
  return parts.join('/');
}

function openDeviceHistory(ip, name, category) {
  const raw = window.deviceHistoryData[ip] || [];
  const hist = filterHistoryForDisplay(raw, category);
  displayDeviceHistory(ip, name, category, hist);
  document.getElementById('device-history-modal').style.display = 'block';
}
function displayDeviceHistory(ip, name, category, hist) {
  const header = document.getElementById('device-history-header');
  const container = document.getElementById('device-history');
  header.innerHTML = `<h3>${name} (${ip})</h3><hr>`;

  if (!hist.length) {
    container.innerHTML = '<p>No downtime ≥5 min in history.</p>';
    return;
  }

  let html = `<table border="1" style="width:100%;text-align:center;border-collapse:collapse;">
    <thead><tr>
      <th>Sr.No</th><th>Date</th><th>Day</th><th>Time</th><th>Status</th><th>Duration</th>
    </tr></thead><tbody>`;

  let idx = 1;
  let lastOff = null;

  hist.forEach(e => {
    const t = new Date(e.timestamp);
    const date = t.toLocaleDateString();
    const day = t.toLocaleString('en-US', { weekday: 'long' });
    const time = t.toLocaleTimeString();
    let dur = '-';

    if (e.status === 'Offline') {
      // Only set lastOff if it's null (start of a new Offline period)
      if (!lastOff) {
        lastOff = e.timestamp;
        html += `<tr>
          <td>${idx++}</td><td>${date}</td><td>${day}</td><td>${time}</td>
          <td style="color:red">${e.status}</td><td>${dur}</td>
        </tr>`;
      }
      // If already Offline, ignore duplicate entries until Online appears
    } else if (e.status === 'Online') {
      if (lastOff) {
        const diff = (new Date(e.timestamp) - new Date(lastOff)) / 1000;
        dur = formatDuration(diff);
        const offTime = new Date(lastOff);
        const offDate = offTime.toLocaleDateString();
        const offDay = offTime.toLocaleString('en-US', { weekday: 'long' });
        const offClock = offTime.toLocaleTimeString();

        // Output Offline row with calculated duration
        html += `<tr>
          <td>${idx++}</td><td>${offDate}</td><td>${offDay}</td><td>${offClock}</td>
          <td style="color:red">Offline</td><td>${dur}</td>
        </tr>`;

        // Output Online row
        html += `<tr>
          <td>${idx++}</td><td>${date}</td><td>${day}</td><td>${time}</td>
          <td style="color:green">${e.status}</td><td>${formatDuration(0)}</td>
        </tr>`;

        lastOff = null; // Reset after pairing
      } else {
        // Online entry without a preceding Offline
        html += `<tr>
          <td>${idx++}</td><td>${date}</td><td>${day}</td><td>${time}</td>
          <td style="color:green">${e.status}</td><td>${dur}</td>
        </tr>`;
      }
    }
  });

  // If history ends with unmatched Offline (ongoing)
  if (lastOff) {
    const t = new Date(lastOff);
    const date = t.toLocaleDateString();
    const day = t.toLocaleString('en-US', { weekday: 'long' });
    const time = t.toLocaleTimeString();
    const now = Date.now();
    const dur = formatDuration((now - new Date(lastOff)) / 1000);

    html += `<tr>
      <td>${idx++}</td><td>${date}</td><td>${day}</td><td>${time}</td>
      <td style="color:red">Offline</td><td>${dur}</td>
    </tr>`;
  }

  html += `</tbody></table>`;
  container.innerHTML = `<div class="scrollable-history-table">${html}</div>`;
}



function closeHistoryModal() {
  document.getElementById('device-history-modal').style.display = 'none';
}

function filterData() {
  const typeSel   = document.getElementById('device-type').value.toUpperCase();
  const remarkSel = document.getElementById('remark-filter').value.toUpperCase();
  const searchTxt = document.getElementById('search-input').value.toUpperCase();
  document.querySelectorAll('#device-table tbody tr').forEach(r => {
    const type   = r.cells[3].textContent.toUpperCase();
    const remark = r.cells[8].textContent.toUpperCase();
    const ip     = r.cells[1].textContent.toUpperCase();
    const name   = r.cells[2].textContent.toUpperCase();
    const show   = (typeSel==='ALL'||type===typeSel)
                 && (remarkSel==='ALL'||remark.includes(remarkSel))
                 && (ip.includes(searchTxt)||name.includes(searchTxt));
    r.style.display = show ? '' : 'none';
  });
}

function copyToClipboard(id) {
  const t = document.getElementById(id)?.innerText;
  if (t) navigator.clipboard.writeText(t);
}

document.addEventListener('DOMContentLoaded', () => {
  ['region','device-type','remark-filter'].forEach(id => {
    document.getElementById(id)?.addEventListener('change', id==='region'?fetchDeviceData:filterData);
  });
  document.getElementById('search-input')?.addEventListener('input', filterData);
  fetchDeviceData();
});
