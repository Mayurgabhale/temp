from: `${from.getFullYear()}-${(from.getMonth() + 1).toString().padStart(2, '0')}-${from.getDate().toString().padStart(2, '0')}T00:00:00`,
to: `${to.getFullYear()}-${(to.getMonth() + 1).toString().padStart(2, '0')}-${to.getDate().toString().padStart(2, '0')}T23:59:59`,







const params = {
  ...baseParams,
  from: from.toISOString().slice(0, 10) + 'T00:00:00',
  to: to.toISOString().slice(0, 10) + 'T23:59:59',
  employees: selectedEmps.join(',')
};








// src/pages/ReportsPage.jsx
import React, { useState } from 'react';
import {
  Box, FormControl, InputLabel, Select, OutlinedInput,
  Checkbox, ListItemText, MenuItem, Button,
  CircularProgress, Typography, TextField, Tabs, Tab
} from '@mui/material';
import { DatePicker } from '@mui/x-date-pickers/DatePicker';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { StaticDatePicker } from '@mui/x-date-pickers/StaticDatePicker';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import axios from 'axios';
import ExcelJS from 'exceljs';
import * as XLSX from 'xlsx';

// Static lists
const EMPLOYEE_OPTIONS = [
  'Vainilaitis, Valdas',
  'Tomasevic, Kazimez',
  'Sesickis, Janas',
  'Valiunas, Sigitas'
];
const REGION_OPTIONS = ['apac', 'emea', 'laca', 'namer'];
const LOCATION_MAP = {
  apac: ['APAC.Default', 'CN.Beijing', 'JP.Tokyo', 'PH.Manila', 'MY.Kuala Lumpur', 'IN.Pune'],
  emea: ['AUT.Vienna', 'DU.Abu Dhab', 'IE.Dublin', 'IT.Rome', 'LT.Vilnius', 'MA.Casablanca', 'RU.Moscow', 'UK.London', 'ES.Madrid'],
  laca: ['AR.Cordoba', 'CR.Costa Rica Partition', 'MX.Mexico City', 'PE.Lima', 'BR.Sao Paulo'],
  namer: ['US.NYC', 'US.Denver', 'US.Austin', 'US.Miami']
};

function formatDisplayDate(date) {
  const d = new Date(date);
  const day = d.getDate();
  const suf = day % 10 === 1 && day !== 11 ? 'st'
    : day % 10 === 2 && day !== 12 ? 'nd'
      : day % 10 === 3 && day !== 13 ? 'rd' : 'th';
  const mon = d.toLocaleString('default', { month: 'long' });
  return `${day}${suf} ${mon} ${d.getFullYear()}`;
}

export default function ReportsPage() {
  // --- state ---
  const [tab, setTab] = useState(0);

  const [region, setRegion] = useState('emea');
  const [location, setLocation] = useState('');
  const [from, setFrom] = useState(null);
  const [to, setTo] = useState(null);
  const [showFromCal, setShowFromCal] = useState(false);
  const [showToCal, setShowToCal] = useState(false);
  const [selectedEmps, setSelectedEmps] = useState([]);
  const [loading, setLoading] = useState(false);

  // Handle tab switch (Daily / Raw / Rejection)
  const handleTabChange = (_, v) => {
    setTab(v);
    // reset all filters
    setRegion('emea');
    setLocation('');
    setFrom(null);
    setTo(null);
    setSelectedEmps([]);
  };




  /** Time Duration Excel generator */
  const generateTimeDurationExcel = async data => {
    const wb = new ExcelJS.Workbook();
    const ws = wb.addWorksheet('Time Duration');

    // Title row
    ws.mergeCells('A1:M1');
    ws.getCell('A1').value =
      `${region.toUpperCase()} Time Duration Report - ${formatDisplayDate(from)}`;
    ws.getCell('A1').font = { bold: true, size: 14 };
    ws.getCell('A1').alignment = { horizontal: 'center' };
    // Header row
    const headers = [
      'Sr. No.', 'Employee Name', 'Employee ID', 'Personnel Type',
      'Partition', 'Text5', 'Year', 'Week', 'Date',
      'First Swipe', 'Last Swipe', 'Duration', 'Category',
      'Days Present', 'Violation Days', 'Clean Days', 'Defaulter'
    ];
    const headerRow = ws.addRow(headers);
    headerRow.font = { bold: true };
    headerRow.alignment = { horizontal: 'center', vertical: 'middle' };
    headerRow.eachCell(c => {
      c.border = {
        top: { style: 'thin' }, left: { style: 'thin' },
        bottom: { style: 'thin' }, right: { style: 'thin' }
      };
    });

    // Columns widths
    ws.columns = [
      { key: 'sr', width: 8 },
      { key: 'name', width: 25 },
      { key: 'id', width: 15 },
      { key: 'ptype', width: 18 },
      { key: 'part', width: 15 },
      { key: 'txt5', width: 20 },
      { key: 'year', width: 8 },
      { key: 'week', width: 6 },
      { key: 'date', width: 12 },
      { key: 'first', width: 16 },
      { key: 'last', width: 16 },
      { key: 'dur', width: 10 },
      { key: 'cat', width: 12 },
      { key: 'dpw', width: 12 },
      { key: 'vdw', width: 14 },
      { key: 'cdw', width: 12 },
      { key: 'def', width: 10 }
    ];

    data.forEach((r, idx) => {
      const first = new Date(r.FirstSwipeTime);
      const last = new Date(r.LastSwipeTime);
      const date = new Date(r.ShiftedDate);
      const row = ws.addRow([
        idx + 1,
        r.ObjectName1,
        r.EmployeeID,
        r.PersonnelType,
        r.PartitionName2,
        r.text5,
        r.YearNumber,
        r.WeekNumber,
        date,
        first,
        last,
        r.DurationHHMM,
        r.TimeDiffCategory,
        r.DaysPresentInWeek,
        r.ViolationDaysInWeek,
        r.CleanDaysInWeek,
        r.Defaulter
      ]);

      // Date & time formatting
      row.getCell(9).numFmt = 'dd-mmm-yy';
      row.getCell(10).numFmt = 'h:mm:ss AM/PM';
      row.getCell(11).numFmt = 'h:mm:ss AM/PM';

      row.eachCell(c => {
        c.border = {
          top: { style: 'thin' }, left: { style: 'thin' },
          bottom: { style: 'thin' }, right: { style: 'thin' }
        };
        c.alignment = { vertical: 'middle', horizontal: 'left' };
      });
    });

    ws.autoFilter = 'A2:Q2';

    const buf = await wb.xlsx.writeBuffer();
    const blob = new Blob([buf], {
      type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    });
    const filename =
      `TimeDuration_${region.toUpperCase()}_${formatDisplayDate(from)}.xlsx`;
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    link.click();
  };


  // --- Excel for Daily Access (unchanged) ---
  const generateDailyAccessExcel = async allRows => {
    const wb = new ExcelJS.Workbook();
    for (const emp of selectedEmps) {
      const ws = wb.addWorksheet(emp.substring(0, 31));
      ws.addRow([
        'Date', 'Time', 'Name', 'Contractor ID', 'Card No',
        'Door Name', 'Message Type', 'Partition', 'Swipe'
      ]);
      const hdr = ws.getRow(1);
      hdr.font = { bold: true };
      hdr.alignment = { vertical: 'middle', horizontal: 'center' };
      hdr.eachCell(c => {
        c.border = {
          top: { style: 'thin' }, left: { style: 'thin' },
          bottom: { style: 'thin' }, right: { style: 'thin' }
        };
      });
      ws.columns = [
        { key: 'date', width: 12 },
        { key: 'time', width: 12 },
        { key: 'name', width: 25 },
        { key: 'id', width: 15 },
        { key: 'card', width: 15 },
        { key: 'door', width: 40 },
        { key: 'msg', width: 15 },
        { key: 'part', width: 15 },
        { key: 'swipe', width: 10 }
      ];
      const rows = allRows.filter(r => r.ObjectName1 === emp);
      if (!rows.length) {
        ws.mergeCells('A2', 'I2');
        ws.getCell('A2').value = 'There is no swipe records found in Ccure';
        ws.getCell('A2').alignment = { horizontal: 'center' };
      } else {
        rows.forEach(r => {
          const dt = new Date(r.LocaleMessageTime);
          const row = ws.addRow([
            dt, dt,
            r.ObjectName1,
            r.EmployeeID,
            r.CardNumber,
            r.Door || r.ObjectName2 || '',
            r.AdmitCode || r.Messagetype || '',
            r.location,
            r.Swipe || r.Direction || ''
          ]);
          row.getCell(1).numFmt = 'dd-mmm-yy';
          row.getCell(2).numFmt = 'h:mm:ss AM/PM';
          row.eachCell(c => {
            c.border = {
              top: { style: 'thin' }, left: { style: 'thin' },
              bottom: { style: 'thin' }, right: { style: 'thin' }
            };
            c.alignment = { vertical: 'middle', horizontal: 'left' };
          });
        });
      }
      ws.autoFilter = 'A1:I1';
    }

    const buf = await wb.xlsx.writeBuffer();
    const blob = new Blob([buf], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
    const filename = `Daily Access Report(${formatDisplayDate(from)} to ${formatDisplayDate(to)}).xlsx`;
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    link.click();
  };

  // --- Excel for Rejection (unchanged) ---
  const generateRejectionExcel = async data => {
    const wb = new ExcelJS.Workbook();
    const ws = wb.addWorksheet('Rejection');

    // Title
    const title = `${region.toUpperCase()} Rejection Report - ${formatDisplayDate(from)}`;
    ws.mergeCells('A1:J1');
    ws.getCell('A1').value = title;
    ws.getCell('A1').font = { bold: true, size: 14 };
    ws.getCell('A1').alignment = { horizontal: 'center' };

    // Header
    const headers = [
      'Sr. No.', 'Date', 'Time', 'Employee Name', 'Employee ID',
      'Access Card No.', 'Rejection Type', 'Door Name', 'Location', 'Swipe'
    ];
    const headerRow = ws.addRow(headers);
    headerRow.font = { bold: true };
    headerRow.alignment = { vertical: 'middle', horizontal: 'center' };
    headerRow.eachCell(c => {
      c.border = {
        top: { style: 'thin' }, left: { style: 'thin' },
        bottom: { style: 'thin' }, right: { style: 'thin' }
      };
    });

    // Columns
    ws.columns = [
      { key: 'sr', width: 8 },
      { key: 'date', width: 12 },
      { key: 'time', width: 12 },
      { key: 'name', width: 25 },
      { key: 'id', width: 15 },
      { key: 'card', width: 15 },
      { key: 'type', width: 15 },
      { key: 'door', width: 40 },
      { key: 'loc', width: 15 },
      { key: 'swipe', width: 10 }
    ];

    // Data
    data.forEach((r, idx) => {
      const d = r.DateOnly ? new Date(r.DateOnly) : new Date(r.LocaleMessageTime);
      const t = r.Swipe_Time ? new Date(r.Swipe_Time) : new Date(r.LocaleMessageTime);
      const row = ws.addRow([
        idx + 1, d, t,
        r.ObjectName1 || '0',
        r.EmployeeID || '0',
        r.CardNumber || '0',
        r.Rejection_Type || '',
        r.Door || '',
        r.location || '',
        r.Direction || r.Swipe || ''
      ]);
      row.getCell(2).numFmt = 'dd-mmm-yy';
      row.getCell(3).numFmt = 'h:mm:ss AM/PM';
      row.eachCell(c => {
        c.border = {
          top: { style: 'thin' }, left: { style: 'thin' },
          bottom: { style: 'thin' }, right: { style: 'thin' }
        };
        c.alignment = { vertical: 'middle', horizontal: 'left' };
      });
    });

    // Summary
    const counts = data.reduce((a, r) => {
      const k = r.Rejection_Type || 'Unknown';
      a[k] = (a[k] || 0) + 1; return a;
    }, {});
    let rowIdx = 3;
    ws.getCell(rowIdx, 11).value = 'Rejection';
    ws.getCell(rowIdx, 12).value = 'Count';
    [11, 12].forEach(c => {
      const cell = ws.getCell(rowIdx, c);
      cell.font = { bold: true };
      cell.alignment = { horizontal: 'center' };
      cell.border = {
        top: { style: 'thin' }, left: { style: 'thin' },
        bottom: { style: 'thin' }, right: { style: 'thin' }
      };
    });
    rowIdx++;
    Object.entries(counts).forEach(([type, cnt]) => {
      ws.getCell(rowIdx, 11).value = type;
      ws.getCell(rowIdx, 12).value = cnt;
      [11, 12].forEach(c => {
        const cell = ws.getCell(rowIdx, c);
        cell.alignment = { horizontal: 'left' };
        cell.border = {
          top: { style: 'thin' }, left: { style: 'thin' },
          bottom: { style: 'thin' }, right: { style: 'thin' }
        };
      });
      rowIdx++;
    });
    // Total
    ws.getCell(rowIdx, 11).value = 'Total';
    ws.getCell(rowIdx, 12).value = data.length;
    [11, 12].forEach(c => {
      const cell = ws.getCell(rowIdx, c);
      cell.font = { bold: true };
      cell.alignment = { horizontal: 'left' };
      cell.border = {
        top: { style: 'thin' }, left: { style: 'thin' },
        bottom: { style: 'thin' }, right: { style: 'thin' }
      };
    });

    // Download
    const buf = await wb.xlsx.writeBuffer();
    const blob = new Blob([buf], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
    const filename = `${region.toUpperCase()} Rejection Report - ${formatDisplayDate(from)}.xlsx`;
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    link.click();
  };





  // --- Export driver ---


  const handleGenerate = async () => {
    setLoading(true);
    try {
      const baseParams = {
        region,
        location: location || undefined
      };

      if (tab === 0) {
        // Daily Access
        const params = {
          ...baseParams,
          from: from.toISOString().slice(0, 10) + 'T08:00:00',
          to: to.toISOString().slice(0, 10) + 'T08:00:00',
          employees: selectedEmps.join(',')
        };
        const resp = await axios.get('/api/reports/daily-access', { params });
        await generateDailyAccessExcel(resp.data.data);
      }

      // else if (tab === 1) {
      //   // Raw
      //   const params = {
      //     ...baseParams,
      //     startDate: from.toISOString().slice(0, 10)
      //   };
      //   const resp = await axios.get('/api/reports/raw', { params });
      //   // filter by date
      //   const iso = params.startDate;
      //   const rows = resp.data.data.filter(r =>
      //     (r.DateOnly || r.LocaleMessageTime).slice(0, 10) === iso
      //   );
      //   const ws = XLSX.utils.json_to_sheet(rows);
      //   const wb = XLSX.utils.book_new();
      //   XLSX.utils.book_append_sheet(wb, ws, 'Raw');
      //   XLSX.writeFile(wb, `RawReport_${region}_${iso}.xlsx`);
      // }

      else if (tab === 1) {
        // Raw
        const params = {
          ...baseParams,
          startDate: from.toISOString().slice(0, 10),
          endDate: to.toISOString().slice(0, 10)  // Add endDate parameter
        };
        const resp = await axios.get('/api/reports/raw', { params });
        // filter by date range
        const startIso = params.startDate;
        const endIso = params.endDate;
        const rows = resp.data.data.filter(r => {
          const date = (r.DateOnly || r.LocaleMessageTime).slice(0, 10);
          return date >= startIso && date <= endIso;
        });
        const ws = XLSX.utils.json_to_sheet(rows);
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, 'Raw');
        XLSX.writeFile(wb, `RawReport_${region}_${startIso}_to_${endIso}.xlsx`);
      }



      else if (tab === 2) {
        // Rejection
        const params = {
          ...baseParams,
          date: from.toISOString().slice(0, 10)
        };
        const resp = await axios.get('/api/reports/rejection', { params });
        const iso = params.date;
        const rows = resp.data.data.filter(r =>
          (r.DateOnly || r.LocaleMessageTime).slice(0, 10) === iso
        );
        await generateRejectionExcel(rows);
      }
      else if (tab === 3) {
        const params = {
          ...baseParams,
          startDate: from.toISOString().slice(0, 10),
          partition: location.split('.').pop()  // e.g. "Default"
        };
        const resp = await axios.get(
          '/api/reports/time-duration',
          { params }
        );
        await generateTimeDurationExcel(resp.data.data);
      }

    } catch (err) {
      console.error(err);
      alert('Failed to generate report');
    } finally {
      setLoading(false);
    }
  };

  // const disabled = loading
  //   || !region
  //   || (tab === 0 && (!from || !to || selectedEmps.length === 0))
  //   || (tab === 1 && !from)
  //   || (tab === 2 && !from)
  //   || (tab === 3 && !from);

  
const disabled = loading
  || !region
  || (tab === 0 && (!from || !to || selectedEmps.length === 0))
  || ((tab === 1 || tab === 3) && (!from || !to))  // Changed to require both dates for Raw and Time Duration
  || (tab === 2 && !from);

  return (
    <Box py={4} sx={{ backgroundColor: '#121212', minHeight: '100vh' }}>
      {/* Header Section */}
      <Box
        sx={{
          backgroundColor: '#000',
          color: '#FFCC00',
          textAlign: 'center',

          mb: 4,
          borderBottom: '4px solid #FFCC00',
        }}
      >
        <Typography variant="h4" py={1}>
          Global Security Operation Center Reports
        </Typography>
      </Box>

      {/* Tabs */}
      <Tabs
        value={tab}
        onChange={handleTabChange}
        centered
        textColor="#FFF"
        indicatorColor="secondary"
        sx={{
          mb: 3,
          '.Mui-selected': { color: '#FFF' },
          '.MuiTabs-indicator': { backgroundColor: '#FFCC00' },
          borderColor: ' #FFCC00',
        }}
      >
        <Tab label="Daily Access" />
        <Tab label="Raw" />
        <Tab label="Rejection" />
        <Tab label="Time Duration" />
      </Tabs>

      {/* Filter Section */}
      <LocalizationProvider dateAdapter={AdapterDateFns}>
        <Box display="flex" flexWrap="wrap" gap={2} mb={4}>
          {/* Region */}

          <FormControl sx={{ minWidth: 250 }}>
            <InputLabel>Region</InputLabel>
            <Select
              value={region}
              onChange={e => { setRegion(e.target.value); setLocation(''); }}
              input={<OutlinedInput label="Region" sx={{
                '& .MuiOutlinedInput-notchedOutline': {
                  borderColor: '#FFF' // White border
                },
                '&:hover .MuiOutlinedInput-notchedOutline': {
                  borderColor: '#FFF' // White border on hover
                }
              }} />}
              sx={{
                '& .MuiOutlinedInput-notchedOutline': {
                  borderColor: '#FFF' // White border
                },
                '&:hover .MuiOutlinedInput-notchedOutline': {
                  borderColor: '#FFF' // White border on hover
                }
              }}
            >
              {REGION_OPTIONS.map(r =>
                <MenuItem key={r} value={r}>{r.toUpperCase()}</MenuItem>
              )}
            </Select>
          </FormControl>

          {/* Location */}
          <FormControl sx={{ minWidth: 250 }}>
            <InputLabel>Location</InputLabel>
            <Select
              value={location}
              onChange={e => setLocation(e.target.value)}
              input={<OutlinedInput label="Location" sx={{
                '& .MuiOutlinedInput-notchedOutline': {
                  borderColor: '#FFF' // White border
                },
                '&:hover .MuiOutlinedInput-notchedOutline': {
                  borderColor: '#FFF' // White border on hover
                }
              }} />}
              sx={{
                '& .MuiOutlinedInput-notchedOutline': {
                  borderColor: '#FFF' // White border
                },
                '&:hover .MuiOutlinedInput-notchedOutline': {
                  borderColor: '#FFF' // White border on hover
                }
              }}
              disabled={!region}
            >
              {(LOCATION_MAP[region] || []).map(loc =>
                <MenuItem key={loc} value={loc}>
                  {loc.split('.').pop()}
                </MenuItem>
              )}
            </Select>
          </FormControl>

          {/* From Date */}
          <Box sx={{ position: 'relative' }}>
            <TextField
              label={tab === 0 ? 'From Date' : 'Start Date'}
              value={from ? from.toLocaleDateString() : ''}
              readOnly
              onClick={() => setShowFromCal(true)}
              sx={{
                '& .MuiOutlinedInput-root': {
                  '& fieldset': {
                    borderColor: '#FFF', // ONLY border color changed to white
                  },
                  '&:hover fieldset': {
                    borderColor: '#FFF', // ONLY border color changed to white
                  }
                }
              }}
            />
            {showFromCal && (
              <StaticDatePicker
                displayStaticWrapperAs="desktop"
                value={from}
                onChange={(newValue) => setFrom(newValue)}
                onAccept={() => setShowFromCal(false)}
                onClose={() => setShowFromCal(false)}
                renderInput={(params) => <TextField {...params} />}
              />
            )}
          </Box>

          {/* To Date */}
          <Box sx={{ position: 'relative' }}>
            <TextField
              label={tab === 0 ? 'To Date' : 'End Date'}
              value={to ? to.toLocaleDateString() : ''}
              readOnly
              onClick={() => setShowToCal(true)}
              disabled={false}
              sx={{
                '& .MuiOutlinedInput-root': {
                  '& fieldset': {
                    borderColor: '#FFF', // ONLY border color changed to white
                  },
                  '&:hover fieldset': {
                    borderColor: '#FFF', // ONLY border color changed to white
                  }
                }
              }}
            />
            {showToCal && (
              <StaticDatePicker
                displayStaticWrapperAs="desktop"
                value={to}
                onChange={(newValue) => setTo(newValue)}
                onAccept={() => setShowToCal(false)}
                onClose={() => setShowToCal(false)}
                renderInput={(params) => <TextField {...params} />}
              />
            )}
          </Box>

          {/* Employees (only Daily) */}
          {tab === 0 && (
            <FormControl sx={{ minWidth: 250 }}>
              <InputLabel>Employees</InputLabel>
              <Select
                multiple
                value={selectedEmps}
                onChange={e => setSelectedEmps(e.target.value)}
                input={<OutlinedInput label="Employees" sx={{
                  '& .MuiOutlinedInput-notchedOutline': {
                    borderColor: '#FFF' // White border
                  },
                  '&:hover .MuiOutlinedInput-notchedOutline': {
                    borderColor: '#FFF' // White border on hover
                  }
                }} />}
                sx={{
                  '& .MuiOutlinedInput-notchedOutline': {
                    borderColor: '#FFF' // White border
                  },
                  '&:hover .MuiOutlinedInput-notchedOutline': {
                    borderColor: '#FFF' // White border on hover
                  }
                }}
                renderValue={vals => vals.join(', ')}
              >
                {EMPLOYEE_OPTIONS.map(n => (
                  <MenuItem key={n} value={n}>
                    <Checkbox checked={selectedEmps.includes(n)} />
                    <ListItemText primary={n} />
                  </MenuItem>
                ))}
              </Select>
            </FormControl>
          )}


        </Box>
      </LocalizationProvider>

      {/* Action Button */}
      <Box textAlign="center">
        <Button
          variant="contained"
          size="large"
          onClick={handleGenerate}
          disabled={disabled}
          startIcon={loading ? <CircularProgress size={20} /> : null}
          sx={{
            backgroundColor: '#FFCC00',
            color: 'black',
            fontWeight: 'bold',
            px: 4,
            '&:hover': {
              backgroundColor: '#f4d03f',
            },
          }}
        >
          {loading ? 'Generating…' : 'Export to Excel'}
        </Button>
      </Box>
    </Box>
  );


}
