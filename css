function displayDeviceHistory(ip, name, category, hist) {
  const header = document.getElementById('device-history-header');
  const container = document.getElementById('device-history');
  header.innerHTML = `<h3>${name} (${ip})</h3><hr>`;

  if (!hist.length) {
    container.innerHTML = '<p>No downtime ≥5 min in history.</p>';
    return;
  }

  let html = `<table border="1" style="width:100%;text-align:center;border-collapse:collapse;">
    <thead><tr>
      <th>Sr.No</th><th>Date</th><th>Day</th><th>Time</th><th>Status</th><th>Duration</th>
    </tr></thead><tbody>`;

  let idx = 1;
  let lastOff = null;

  hist.forEach(e => {
    const t = new Date(e.timestamp);
    const date = t.toLocaleDateString();
    const day = t.toLocaleString('en-US', { weekday: 'long' });
    const time = t.toLocaleTimeString();
    let dur = '-';

    if (e.status === 'Offline') {
      // Only set lastOff if it's null (start of a new Offline period)
      if (!lastOff) {
        lastOff = e.timestamp;
        html += `<tr>
          <td>${idx++}</td><td>${date}</td><td>${day}</td><td>${time}</td>
          <td style="color:red">${e.status}</td><td>${dur}</td>
        </tr>`;
      }
      // If already Offline, ignore duplicate entries until Online appears
    } else if (e.status === 'Online') {
      if (lastOff) {
        const diff = (new Date(e.timestamp) - new Date(lastOff)) / 1000;
        dur = formatDuration(diff);
        const offTime = new Date(lastOff);
        const offDate = offTime.toLocaleDateString();
        const offDay = offTime.toLocaleString('en-US', { weekday: 'long' });
        const offClock = offTime.toLocaleTimeString();

        // Output Offline row with calculated duration
        html += `<tr>
          <td>${idx++}</td><td>${offDate}</td><td>${offDay}</td><td>${offClock}</td>
          <td style="color:red">Offline</td><td>${dur}</td>
        </tr>`;

        // Output Online row
        html += `<tr>
          <td>${idx++}</td><td>${date}</td><td>${day}</td><td>${time}</td>
          <td style="color:green">${e.status}</td><td>${formatDuration(0)}</td>
        </tr>`;

        lastOff = null; // Reset after pairing
      } else {
        // Online entry without a preceding Offline
        html += `<tr>
          <td>${idx++}</td><td>${date}</td><td>${day}</td><td>${time}</td>
          <td style="color:green">${e.status}</td><td>${dur}</td>
        </tr>`;
      }
    }
  });

  // If history ends with unmatched Offline (ongoing)
  if (lastOff) {
    const t = new Date(lastOff);
    const date = t.toLocaleDateString();
    const day = t.toLocaleString('en-US', { weekday: 'long' });
    const time = t.toLocaleTimeString();
    const now = Date.now();
    const dur = formatDuration((now - new Date(lastOff)) / 1000);

    html += `<tr>
      <td>${idx++}</td><td>${date}</td><td>${day}</td><td>${time}</td>
      <td style="color:red">Offline</td><td>${dur}</td>
    </tr>`;
  }

  html += `</tbody></table>`;
  container.innerHTML = `<div class="scrollable-history-table">${html}</div>`;
}





....
Sr.No	Date	Day	Time          	Status	             Duration
1	7/29/2025	Tuesday	9:48:31 AM	Offline	-
2	7/29/2025	Tuesday	9:48:31 AM	Offline	1h/25m/31s




Sr.No	Date	Day	      Time	         Status	            Duration
1	7/26/2025	Saturday	1:31:38 PM	Offline	-
2	7/26/2025	Saturday	1:36:50 PM	Online	5m/12s this is correct 
3	7/29/2025	Tuesday	9:55:30 AM	Offline	-      <----    and it is empty not show anything 
4	7/29/2025	Tuesday	10:01:50 AM	Online	6m/21s

see above data carefully timeing chek timeing between duratin and duration it is incorrect duraion logic 

1	7/29/2025	Tuesday	9:48:31 AM	Offline	- see in between not much differnet but you give 1h/25m/31s this is wrong 
2	7/29/2025	Tuesday	9:48:31 AM	Offline	1h/25m/31s

function displayDeviceHistory(ip, name, category, hist) {
  const header = document.getElementById('device-history-header');
  const container = document.getElementById('device-history');
  header.innerHTML = `<h3>${name} (${ip})</h3><hr>`;
  if (!hist.length) {
    container.innerHTML = '<p>No downtime ≥5 min in history.</p>';
    return;
  }

  let html = `<table border="1" style="width:100%;text-align:center;border-collapse:collapse;">
    <thead><tr>
      <th>Sr.No</th><th>Date</th><th>Day</th><th>Time</th><th>Status</th><th>Duration</th>
    </tr></thead><tbody>`;

  let idx = 1;
  let lastOff = null;

  hist.forEach(e => {
    const t = new Date(e.timestamp);
    const date = t.toLocaleDateString();
    const day = t.toLocaleString('en-US', { weekday: 'long' });
    const time = t.toLocaleTimeString();

    let dur = '-';

    if (e.status === 'Offline') {
      lastOff = e.timestamp; // Don't calculate duration yet
    } else if (e.status === 'Online' && lastOff) {
      const diff = (new Date(e.timestamp) - new Date(lastOff)) / 1000;
      dur = formatDuration(diff);
      lastOff = null;
    }

    html += `<tr>
      <td>${idx++}</td><td>${date}</td><td>${day}</td><td>${time}</td>
      <td style="color:${e.status === 'Online' ? 'green' : 'red'}">${e.status}</td>
      <td>${dur}</td>
    </tr>`;
  });

  // Handle ongoing Offline (last entry doesn't have Online yet)
  if (lastOff) {
    const t = new Date(lastOff);
    const date = t.toLocaleDateString();
    const day = t.toLocaleString('en-US', { weekday: 'long' });
    const time = t.toLocaleTimeString();
    const now = Date.now();
    const dur = formatDuration((now - new Date(lastOff)) / 1000);

    html += `<tr>
      <td>${idx++}</td><td>${date}</td><td>${day}</td><td>${time}</td>
      <td style="color:red">Offline</td>
      <td>${dur}</td>
    </tr>`;
  }

  html += `</tbody></table>`;
  container.innerHTML = `<div class="scrollable-history-table">${html}</div>`;
}










let deviceUptimeTimers = {};
let deviceDowntimeTimers = {};

// Utility to turn an IP (or any string) into a safe DOM-ID fragment
function sanitizeId(str) {
  return (str || '').replace(/[^a-zA-Z0-9]/g, '_');
}

function fetchDeviceData() {
  const region = document.getElementById('region').value;
  fetch(`http://localhost/api/regions/details/${region}`)
    .then(r => r.json())
    .then(d => fetchDeviceHistory(d.details))
    .catch(console.error);
}

function fetchDeviceHistory(details) {
  fetch(`http://localhost/api/devices/history`)
    .then(r => r.json())
    .then(historyData => {
      populateDeviceTable(details, historyData);
      window.deviceHistoryData = historyData;
    })
    .catch(console.error);
}

function populateDeviceTable(details, historyData) {
  const tbody = document.querySelector('#device-table tbody');
  tbody.innerHTML = '';

  const devices = [];
  ['cameras','archivers','controllers','servers'].forEach(type => {
    (details[type] || []).forEach(dev => {
      const ip        = dev.ip_address;
      const safe      = sanitizeId(ip);
      const name      = dev[type.slice(0,-1) + 'name'] || 'Unknown';
      const category  = type.slice(0,-1).toUpperCase();
      const rawHist   = historyData[ip] || [];
      const hist      = filterHistoryForDisplay(rawHist, category);
      const lastRaw   = rawHist[rawHist.length-1]?.status || 'Unknown';
      // if last raw Offline but <5min, treat Online
      let status = lastRaw;
      if (lastRaw === 'Offline' && ((Date.now() - new Date(rawHist[rawHist.length-1].timestamp)) / 1000) < 300) {
        status = 'Online';
      }
      const downCount = hist.filter(e => e.status === 'Offline').length;

      devices.push({ ip, safe, name, category, rawHist, hist, status, downCount });
    });
  });

  // sort by ongoing ≥5min offline first, then by downCount desc
  devices.sort((a,b) => {
    const now = Date.now();
    const aLast = a.hist[a.hist.length-1], bLast = b.hist[b.hist.length-1];
    const aOff  = aLast?.status==='Offline' ? (now-new Date(aLast.timestamp))/1000 : 0;
    const bOff  = bLast?.status==='Offline' ? (now-new Date(bLast.timestamp))/1000 : 0;
    if ((aOff>=300) !== (bOff>=300)) return aOff>=300 ? -1 : 1;
    return b.downCount - a.downCount;
  });

  devices.forEach((d,i) => {
    const row = tbody.insertRow();
    row.classList.add(d.status==='Online' ? 'status-online' : 'status-offline');
    row.innerHTML = `
<td>${i+1}</td>
<td><span id="ip-${d.safe}" class="copy-text" onclick="copyToClipboard('ip-${d.safe}')">${d.ip}</span></td>
<td><span id="name-${d.safe}" class="copy-text" onclick="copyToClipboard('name-${d.safe}')">${d.name}</span></td>
<td>${d.category}</td>
<td id="uptime-${d.safe}">0h/0m/0s</td>
<td id="downtime-count-${d.safe}">${d.downCount}</td>
<td id="downtime-${d.safe}">0h/0m/0s</td>
<td><button class="history-btn" onclick="openDeviceHistory('${d.ip}','${d.name}','${d.category}')">View History</button></td>
<td id="remark-${d.safe}">–</td>
`;
    if (d.status === 'Online') startUptime(d.ip, d.hist);
    else startDowntime(d.ip, d.hist);

    updateRemarks(d.ip, d.hist, d.status, d.downCount);
  });

  filterData();
}

function filterHistoryForDisplay(hist, category) {
  if (category === 'SERVER') return hist.slice();

  const out = [];
  
  let lastOff = null;
  hist.forEach(e => {
    if (e.status === 'Offline') lastOff = e;
    else if (e.status === 'Online' && lastOff) {
      const diff = (new Date(e.timestamp) - new Date(lastOff.timestamp)) / 1000;
      if (diff >= 300) out.push(lastOff, e);
      lastOff = null;
    }
  });

  if (lastOff) {

    const diff = (Date.now() - new Date(lastOff.timestamp)) / 1000;
    if (diff >= 300) out.push(lastOff);
  }
  
  return out.sort((a,b) => new Date(a.timestamp) - new Date(b.timestamp));
}

function startUptime(ip, hist) {
  const safe = sanitizeId(ip);
  clearInterval(deviceDowntimeTimers[safe]);
  const on = hist.filter(e => e.status==='Online').pop();
  if (!on) return;
  const t0 = new Date(on.timestamp).getTime();
  deviceUptimeTimers[safe] = setInterval(() => {
    document.getElementById(`uptime-${safe}`).innerText = formatDuration(Math.floor((Date.now()-t0)/1000));
  }, 1000);
}

function startDowntime(ip, hist) {
  const safe = sanitizeId(ip);
  clearInterval(deviceUptimeTimers[safe]);
  const off = hist.filter(e => e.status==='Offline').pop();
  if (!off) return;
  const t0 = new Date(off.timestamp).getTime();
  deviceDowntimeTimers[safe] = setInterval(() => {
    const secs = Math.floor((Date.now()-t0)/1000);
    document.getElementById(`downtime-${safe}`).innerText = formatDuration(secs);
    document.getElementById(`downtime-count-${safe}`).innerText = hist.filter(e => e.status==='Offline').length;
    updateRemarks(ip, hist, null, null);
  }, 1000);
}

function updateRemarks(ip, hist, forcedStatus, forcedCount) {
  const safe = sanitizeId(ip);
  // Determine status
  let status = forcedStatus;
  if (!status) {
    const last = hist[hist.length-1]?.status || 'Unknown';
    status = last==='Offline' && ((Date.now()-new Date(hist[hist.length-1].timestamp))/1000)<300
      ? 'Online' : last;
  }
  const count = forcedCount ?? hist.filter(e => e.status==='Offline').length;
  const el = document.getElementById(`remark-${safe}`);
  if (!el) return;
  if (status === 'Offline') {
    el.innerText = count>0 ? 'Device is Offline, needs check.' : 'Device is Offline.';
  } else if (status === 'Online') {
    el.innerText = count>0
      ? `Device is Online, had ${count} downtime events ≥5 min.`
      : 'Device is Online.';
  } else {
    el.innerText = 'Device status unknown.';
  }
}

function formatDuration(sec) {
  const d = Math.floor(sec/86400), h = Math.floor((sec%86400)/3600),
        m = Math.floor((sec%3600)/60), s = Math.round(sec%60);
  const parts = [];
  if (d) parts.push(`${d}d`);
  if (h) parts.push(`${h}h`);
  if (m) parts.push(`${m}m`);
  if (s||!parts.length) parts.push(`${s}s`);
  return parts.join('/');
}

function openDeviceHistory(ip, name, category) {
  const raw = window.deviceHistoryData[ip] || [];
  const hist = filterHistoryForDisplay(raw, category);
  displayDeviceHistory(ip, name, category, hist);
  document.getElementById('device-history-modal').style.display = 'block';
}

function displayDeviceHistory(ip, name, category, hist) {
  const header = document.getElementById('device-history-header');
  const container = document.getElementById('device-history');
  header.innerHTML = `<h3>${name} (${ip})</h3><hr>`;
  if (!hist.length) {
    container.innerHTML = '<p>No downtime ≥5 min in history.</p>';
    return;
  }
  let html = `<table border="1" style="width:100%;text-align:center;border-collapse:collapse;">
    <thead><tr>
      <th>Sr.No</th><th>Date</th><th>Day</th><th>Time</th><th>Status</th><th>Duration</th>
    </tr></thead><tbody>`;
  let idx = 1, lastOff = null;
  hist.forEach(e => {
    const t = new Date(e.timestamp);
    const date = t.toLocaleDateString();
    const day = t.toLocaleString('en-US',{weekday:'long'});
    const time = t.toLocaleTimeString();

    // let dur = '-';
    // if (e.status==='Offline') lastOff = e.timestamp;
    // else if (e.status==='Online' && lastOff) {
    //   const diff = (new Date(e.timestamp)-new Date(lastOff))/1000;
    //   if (diff>=300) dur = formatDuration(diff);
    //   lastOff = null;
    // }


// let dur = '-';
// if (e.status === 'Offline') {
//   lastOff = e.timestamp;
//   const now = Date.now();
//   dur = formatDuration((now - new Date(lastOff)) / 1000); // Show ongoing duration
// } else if (e.status === 'Online' && lastOff) {
//   const diff = (new Date(e.timestamp) - new Date(lastOff)) / 1000;
//   dur = formatDuration(diff);
//   lastOff = null;
// }


let dur = '-';
if (e.status === 'Offline') {
  lastOff = e.timestamp; // Just mark the time, no duration yet
} else if (e.status === 'Online' && lastOff) {
  const diff = (new Date(e.timestamp) - new Date(lastOff)) / 1000;
  dur = formatDuration(diff); // Calculate duration from lastOff to this Online
  lastOff = null;
}





    html += `<tr>
      <td>${idx++}</td><td>${date}</td><td>${day}</td><td>${time}</td>
      <td style="color:${e.status==='Online'?'green':'red'}">${e.status}</td>
      <td>${dur}</td>
    </tr>`;
  });
  html += `</tbody></table>`;
  container.innerHTML = `<div class="scrollable-history-table">${html}</div>`;
}

function closeHistoryModal() {
  document.getElementById('device-history-modal').style.display = 'none';
}

function filterData() {
  const typeSel   = document.getElementById('device-type').value.toUpperCase();
  const remarkSel = document.getElementById('remark-filter').value.toUpperCase();
  const searchTxt = document.getElementById('search-input').value.toUpperCase();
  document.querySelectorAll('#device-table tbody tr').forEach(r => {
    const type   = r.cells[3].textContent.toUpperCase();
    const remark = r.cells[8].textContent.toUpperCase();
    const ip     = r.cells[1].textContent.toUpperCase();
    const name   = r.cells[2].textContent.toUpperCase();
    const show   = (typeSel==='ALL'||type===typeSel)
                 && (remarkSel==='ALL'||remark.includes(remarkSel))
                 && (ip.includes(searchTxt)||name.includes(searchTxt));
    r.style.display = show ? '' : 'none';
  });
}

function copyToClipboard(id) {
  const t = document.getElementById(id)?.innerText;
  if (t) navigator.clipboard.writeText(t);
}

document.addEventListener('DOMContentLoaded', () => {
  ['region','device-type','remark-filter'].forEach(id => {
    document.getElementById(id)?.addEventListener('change', id==='region'?fetchDeviceData:filterData);
  });
  document.getElementById('search-input')?.addEventListener('input', filterData);
  fetchDeviceData();
});
