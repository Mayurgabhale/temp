
const baseUrl = "http://localhost:80/api/regions";
let refreshInterval = 300000; // 5 minutes
let pingInterval = 60000; // 30 seconds
let countdownTime = refreshInterval / 1000; // Convert to seconds
let currentRegion = "global";
let deviceDetailsCache = {}; // Store previous details to prevent redundant updates
let latestDetails = null; // Cache the latest fetched details

document.addEventListener("DOMContentLoaded", () => {
    fetchData("global"); // Load initial data
    startAutoRefresh("global");

    document.querySelectorAll(".region-button").forEach((button) => {
        button.addEventListener("click", () => {
            const region = button.getAttribute("data-region");
            document.getElementById("region-title").textContent = `${region.toUpperCase()} Summary`;
            switchRegion(region);
        });
    });

    document.getElementById("close-modal").addEventListener("click", () => {
        document.getElementById("modal").style.display = "none";
    });
});

function switchRegion(region) {
    clearExistingIntervals(); // Avoid interval duplication
    currentRegion = region;
    deviceDetailsCache = {};
    fetchData(region);
    startAutoRefresh(region);
}

// **Auto-refresh mechanism**
function startAutoRefresh(regionName) {
    fetchData(regionName); // Fetch initial data

    clearExistingIntervals();

    // Start countdown timer
    window.countdownTimer = setInterval(() => {
        document.getElementById("countdown").innerText = `Refreshing in ${countdownTime} seconds`;
        countdownTime--;
        if (countdownTime < 0) countdownTime = refreshInterval / 1000;
    }, 1000);

    // Refresh summary & details every 5 minutes
    window.refreshTimer = setInterval(() => {
        fetchData(regionName);
        countdownTime = refreshInterval / 1000;
    }, refreshInterval);

    // Ping devices every 30 seconds using history API
    window.pingTimer = setInterval(() => {
        pingAllDevices(regionName);
    }, pingInterval);
}

function clearExistingIntervals() {
    clearInterval(window.countdownTimer);
    clearInterval(window.refreshTimer);
    clearInterval(window.pingTimer);
}

// **Fetch summary and details together**
function fetchData(regionName) {
    Promise.all([
        fetch(`${baseUrl}/summary/${regionName}`).then(res => res.json()),
        fetch(`${baseUrl}/details/${regionName}`).then(res => res.json())
    ])
        .then(([summary, details]) => {
            console.log("Summary Data:", summary);
            console.log("Details Data:", details);

            updateSummary(summary);

            if (JSON.stringify(details) !== JSON.stringify(deviceDetailsCache)) {
                updateDetails(details);
                deviceDetailsCache = details; // Update cache
            }
            // Cache details for pinging
            latestDetails = details;
        })
        .catch((error) => console.error("Error fetching data:", error));
}

/*
   Updated pingAllDevices:
   Instead of calling a non-existent ping endpoint, we now use the history API to fetch 
   device history and update each device’s status by updating the separate status dot and text.
*/

function copyToClipboard(text) {
    navigator.clipboard.writeText(text).then(() => {
        alert("IP copied: " + text);
    }).catch(err => {
        console.error("Copy failed", err);
    });
}

function pingAllDevices(regionName) {
    let details = latestDetails;
    if (!details || !details.details) return;

    fetch("http://localhost/api/devices/history")
        .then(response => response.json())
        .then(historyData => {
            let statusChanged = false;

            for (const [key, devices] of Object.entries(details.details)) {
                if (!Array.isArray(devices) || devices.length === 0) continue;

                devices.forEach((device) => {
                    const ip = device.ip_address || "N/A";
                    const card = document.querySelector(`[data-ip="${ip}"]`);
                    if (!card) return;

                    // Determine new status from history API if available.
                    const historyArray = historyData[ip];
                    let newStatus = (device.status || "offline").toLowerCase();
                    if (Array.isArray(historyArray) && historyArray.length > 0) {
                        const latestEntry = historyArray[historyArray.length - 1];
                        newStatus = (latestEntry.status || "offline").toLowerCase();
                    }
                    const currentStatus = card.dataset.status;

                    // Update UI: update the dot and the text.
                    const statusDot = card.querySelector(".status-dot");
                    const statusText = card.querySelector(".status-text");
                    if (statusDot) {
                        statusDot.style.backgroundColor = newStatus === "online" ? "green" : "red";
                        statusDot.classList.remove("online-dot", "offline-dot");
                        statusDot.classList.add(newStatus === "online" ? "online-dot" : "offline-dot");
                    }
                    else {
                        console.warn(`Status dot element not found for IP: ${ip}`);
                    }
                    if (statusText) {
                        const textColor = newStatus === "online" ? "green" : "red";

                        statusText.textContent = newStatus.charAt(0).toUpperCase() + newStatus.slice(1);
                        statusText.style.color = textColor;
                        statusText.style.backgroundColor = "transparent";
                        statusText.style.padding = "0";
                        statusText.style.borderRadius = "0";
                    } else {
                        console.warn(`Status text element not found for IP: ${ip}`);
                    }

                    if (newStatus !== currentStatus) {
                        statusChanged = true;
                        card.dataset.status = newStatus;
                    }
                });
            }

            setTimeout(() => {
                if (statusChanged) {
                    fetchData(regionName);
                }
            }, 5000);
        })
        .catch(error => {
            console.error("Error fetching device history:", error);
        });
}

function updateSummary(data) {
    document.getElementById("total-devices").textContent = data.summary?.totalDevices || "0";
    document.getElementById("online-devices").textContent = data.summary?.totalOnlineDevices || "0";
    document.getElementById("offline-devices").textContent = data.summary?.totalOfflineDevices || "0";

    document.getElementById("camera-total").textContent = data.summary?.cameras?.total || "0";
    document.getElementById("camera-online").textContent = data.summary?.cameras?.online || "0";
    document.getElementById("camera-offline").textContent = data.summary?.cameras?.offline || "0";

    document.getElementById("archiver-total").textContent = data.summary?.archivers?.total || "0";
    document.getElementById("archiver-online").textContent = data.summary?.archivers?.online || "0";
    document.getElementById("archiver-offline").textContent = data.summary?.archivers?.offline || "0";

    document.getElementById("controller-total").textContent = data.summary?.controllers?.total || "0";
    document.getElementById("controller-online").textContent = data.summary?.controllers?.online || "0";
    document.getElementById("controller-offline").textContent = data.summary?.controllers?.offline || "0";

    document.getElementById("server-total").textContent = data.summary?.servers?.total || "0";
    document.getElementById("server-online").textContent = data.summary?.servers?.online || "0";
    document.getElementById("server-offline").textContent = data.summary?.servers?.offline || "0";
}

/*
   Updated updateDetails:
   Each device card is built with separate elements for the status dot and status text.
   This ensures that later updates from pingAllDevices can reliably find and update them.
*/
function updateDetails(data) {
    const detailsContainer = document.getElementById("device-details");
    const deviceFilter = document.getElementById("device-filter");
    const onlineFilterButton = document.getElementById("filter-online");
    const offlineFilterButton = document.getElementById("filter-offline");
    const allFilterButton = document.getElementById("filter-all");
    const cityFilter = document.getElementById("city-filter");

    detailsContainer.innerHTML = "";
    cityFilter.innerHTML = '<option value="all">All Cities</option>';

    let combinedDevices = [];
    let citySet = new Set();

    // Icon utility based on device type
    function getDeviceIcon(type = "") {
        type = type.toLowerCase();
        if (type.includes("camera")) return "fas fa-video";
        if (type.includes("controller")) return "fas fa-cogs";
        if (type.includes("archiver")) return "fas fa-database";
        if (type.includes("server")) return "fas fa-server";
        return "fas fa-microchip"; // fallback
    }




    // Fetch real-time status if available.
    fetch("http://localhost:80/api/region/devices/status")
        .then((response) => response.json())
        .then((realTimeStatus) => {
            console.log("Live Status Data:", realTimeStatus);

            for (const [key, devices] of Object.entries(data.details)) {
                if (!Array.isArray(devices) || devices.length === 0) continue;
                const deviceType = key.toLowerCase();

                devices.forEach((device) => {
                    const deviceIP = device.ip_address || "N/A";
                    let currentStatus = (realTimeStatus[deviceIP] || device.status || "offline").toLowerCase();
                    const city = device.city || "Unknown";
                    citySet.add(city);

                    // Create card element.
                    const card = document.createElement("div");
                    card.className = "device-card";
                    card.dataset.type = deviceType;
                    card.dataset.status = currentStatus;
                    card.dataset.city = city;
                    card.setAttribute("data-ip", deviceIP);

                    // Apply background color based on online/offline status
                    card.style.backgroundColor = currentStatus === "online" ? "#" : "#"; card.style.backgroundColor = currentStatus === "online"
                        ? ""  // Tailwind's emerald-500 with 12% opacity
                        : "";  // Tailwind's red-500 with 12% opacity


                    card.style.borderColor = currentStatus === "online"
                        ? ""
                        : "";

                    // Create a container for status
                    const statusContainer = document.createElement("p");
                    statusContainer.className = "device-status";
                    // statusContainer.textContent = "Status: ";

                    // Status text
                    const statusText = document.createElement("span");
                    statusText.className = "status-text";
                    statusText.textContent = currentStatus.charAt(0).toUpperCase() + currentStatus.slice(1);
                    statusText.style.color = currentStatus === "online" ? "green" : "red";

                    // Status dot
                    const statusDot = document.createElement("span");
                    statusDot.classList.add(currentStatus === "online" ? "online-dot" : "offline-dot");
                    statusDot.style.backgroundColor = (currentStatus === "online") ? "green" : "red";
                    statusDot.style.display = "inline-block";
                    statusDot.style.width = "10px";
                    statusDot.style.height = "10px";
                    statusDot.style.marginLeft = "5px";
                    statusDot.style.marginRight = "5px";
                    statusDot.style.borderRadius = "50%";

                    // Combine status parts
                    statusContainer.appendChild(statusDot);
                    statusContainer.appendChild(statusText);

                    // Use insertAdjacentHTML to avoid overwriting statusContainer
                    // ,,,, ,,m, 

                        card.insertAdjacentHTML("beforeend", `
                                <h3 class="device-name" style="font-size: 1.1rem; font-weight: 700;  font-family: 'Times New Roman', Times, serif;, sans-serif; margin-bottom: 10px;">
                                    ${device.cameraname || device.controllername || device.archivername || device.servername || "Unknown Device"}
                                </h3>

                                <div class="card-content">
                                <p class="device-type-label ${deviceType}" style="font-size: 1.05rem;  font-family: Verdana, Geneva, Tahoma, sans-serif; font-weight: 600; margin-bottom: 10px;">

                                <strong><i class="${getDeviceIcon(deviceType)}" style="margin-right: 5px;"></i> ${deviceType.toUpperCase()}</strong>
                                    </p>

                            <p style="font-size: 1.1rem; font-family: 'Segoe UI', sans-serif; margin-bottom: 8px;">
                                <strong style="color:rgb(8, 8, 8);">
                                    <i class="fas fa-network-wired" style="margin-right: 6px;"></i>
                                </strong>
                                <span 
                                    class="device-ip" 
                                    style="font-weight: 900; color: #00adb5; cursor: pointer; text-shadow: 0 0 1px rgba(0, 173, 181, 0.3); font-family: 'Franklin Gothic Medium', 'Arial Narrow', Arial, sans-serif ;
" 
                                    onclick="copyToClipboard('${deviceIP}')"
                                    title="Click to copy IP"
                                >
                                    ${deviceIP}
                                </span>
                            </p>

                                <p style="font-size: 0.95rem; font-family: 'Segoe UI', sans-serif; margin-bottom: 6px;">
                                    <strong style="color: rgb(13, 13, 13);;"><i class="fas fa-map-marker-alt" style="margin-right: 5px;"></i></strong>
                                    <span style=" font-size: 1rem; font-weight: bold; color: rgb(8, 9, 9);  margin-left: 12px;">${device.location || "N/A"}</span>
                                </p>

                                <p style="font-size: 0.95rem; font-family: 'Segoe UI', sans-serif;">
                                    <strong style="color: rgb(215, 217, 222);;"><i class="fas fa-city" style="margin-right: 5px;"></i></strong>
                                    <span style="font-weight: bold; color: rgb(7, 7, 7);; margin-left: 4px;">${city}</span>
                                </p>

                                </div>

                            `);



//                 card.insertAdjacentHTML("beforeend", `
//   <h3 class="device-name" style="font-size: 1.1rem; font-weight: 700; font-family: 'Times New Roman', Times, serif; margin-bottom: 10px;">
//     ${device.cameraname || device.controllername || device.archivername || device.servername || "Unknown Device"}
//   </h3>

//   <div class="card-content">
//     <i class="${getDeviceIcon(deviceType)}" style="color: #3b3f46;"></i>
//     <strong>${deviceType.toUpperCase()}</strong>

//     <i class="fas fa-network-wired" style="color: #d7d9de;"></i>
//     <span 
//       class="device-ip" 
//       onclick="copyToClipboard('${deviceIP}')" 
//       title="Click to copy IP" 
//       style="cursor: pointer; color: #0077b6;">
//       ${deviceIP}
//     </span>

//     <i class="fas fa-map-marker-alt" style="color: rgb(215, 217, 222);"></i>
//     <span>${device.location || "N/A"}</span>

//     <i class="fas fa-city" style="color: rgb(215, 217, 222);"></i>
//     <span>${city}</span>
//   </div>
// `);
                    card.appendChild(statusContainer);



                    // ............
                    combinedDevices.push({
                        card: card,
                        device: {
                            type: deviceType,
                            status: currentStatus,
                            city: city
                        }
                    });
                });
            }

            combinedDevices.sort((a, b) => {
                const statusA = (a.device.status === "offline") ? 0 : 1;
                const statusB = (b.device.status === "offline") ? 0 : 1;
                return statusA - statusB;
            });

            const allDevices = combinedDevices.map(item => item.card);
            const deviceObjects = combinedDevices.map(item => item.device);

            citySet.forEach((city) => {
                const option = document.createElement("option");
                option.value = city;
                option.textContent = city;
                cityFilter.appendChild(option);
            });

            deviceFilter.value = "all";
            cityFilter.value = "all";
            document.querySelectorAll(".status-filter").forEach(btn => btn.classList.remove("active"));
            allFilterButton.classList.add("active");

            function filterDevices() {
                const selectedType = deviceFilter.value;
                const selectedStatus = document.querySelector(".status-filter.active")?.dataset.status || "all";
                const selectedCity = cityFilter.value;
                // Search bar input
                const searchTerm = document.getElementById("device-search").value.toLowerCase();

                detailsContainer.innerHTML = "";

                // const filteredDevices = allDevices.filter((device) =>
                //     (selectedType === "all" || device.dataset.type === selectedType) &&
                //     (selectedStatus === "all" || device.dataset.status === selectedStatus) &&
                //     (selectedCity === "all" || device.dataset.city === selectedCity)
                // );

                const filteredDevices = allDevices.filter((device) =>
                    (selectedType === "all" || device.dataset.type === selectedType) &&
                    (selectedStatus === "all" || device.dataset.status === selectedStatus) &&
                    (selectedCity === "all" || device.dataset.city === selectedCity) &&
                    (
                        !searchTerm ||
                        device.innerText.toLowerCase().includes(searchTerm)
                    )
                );

                filteredDevices.forEach((deviceCard) => {
                    detailsContainer.appendChild(deviceCard);
                });

                // const region = currentRegion?.toUpperCase() || "GLOBAL";
                // if (selectedCity !== "all") {
                //     document.getElementById("region-title").textContent = `${region}, ${selectedCity} Summary`;
                // } else {
                //     document.getElementById("region-title").textContent = `${region} Summary`;
                // }


                const region = currentRegion?.toUpperCase() || "GLOBAL";
                const titleElement = document.getElementById("region-title");

                const logoHTML = `
                    <span>

                     
                        <img src="images/wu-header.png" alt="Logo"
                            style="height: 50px; width: auto; object-fit: contain; margin-right: 5px;  margin-top: 10px;" />
                    </span>
                    `;
                if (selectedCity !== "all") {
                    titleElement.innerHTML = `${logoHTML}<span>${region}, ${selectedCity} Summary</span>`;
                } else {
                    titleElement.innerHTML = `${logoHTML}<span>${region} Summary</span>`;
                }

                const filteredSummaryDevices = deviceObjects.filter((deviceObj, index) => {
                    const correspondingCard = allDevices[index];
                    return (
                        (selectedType === "all" || correspondingCard.dataset.type === selectedType) &&
                        (selectedStatus === "all" || correspondingCard.dataset.status === selectedStatus) &&
                        (selectedCity === "all" || correspondingCard.dataset.city === selectedCity)
                    );
                });

                const summary = calculateCitySummary(filteredSummaryDevices);
                updateSummary(summary);
            }

            function calculateCitySummary(devices) {
                const summary = {
                    summary: {
                        totalDevices: devices.length,
                        totalOnlineDevices: devices.filter(d => d.status === "online").length,
                        totalOfflineDevices: devices.filter(d => d.status === "offline").length,
                        cameras: { total: 0, online: 0, offline: 0 },
                        archivers: { total: 0, online: 0, offline: 0 },
                        controllers: { total: 0, online: 0, offline: 0 },
                        servers: { total: 0, online: 0, offline: 0 },
                    }
                };

                devices.forEach((device) => {
                    if (!summary.summary[device.type]) return;
                    summary.summary[device.type].total += 1;
                    if (device.status === "online") summary.summary[device.type].online += 1;
                    else summary.summary[device.type].offline += 1;
                });

                return summary;
            }

            filterDevices();

            setTimeout(() => {
                const selectedCity = cityFilter.value;
                const selectedType = deviceFilter.value;
                const selectedStatus = document.querySelector(".status-filter.active")?.dataset.status || "all";

                const filteredSummaryDevices = deviceObjects.filter((deviceObj, index) => {
                    const correspondingCard = allDevices[index];
                    return (
                        (selectedType === "all" || correspondingCard.dataset.type === selectedType) &&
                        (selectedStatus === "all" || correspondingCard.dataset.status === selectedStatus) &&
                        (selectedCity === "all" || correspondingCard.dataset.city === selectedCity)
                    );
                });

                const summary = calculateCitySummary(filteredSummaryDevices);
                updateSummary(summary);
            }, 100);

            deviceFilter.addEventListener("change", filterDevices);
            // Search bar input
            document.getElementById("device-search").addEventListener("input", filterDevices);
            cityFilter.addEventListener("change", filterDevices);
            allFilterButton.addEventListener("click", () => {
                document.querySelectorAll(".status-filter").forEach(btn => btn.classList.remove("active"));
                allFilterButton.classList.add("active");
                filterDevices();
            });
            onlineFilterButton.addEventListener("click", () => {
                document.querySelectorAll(".status-filter").forEach(btn => btn.classList.remove("active"));
                onlineFilterButton.classList.add("active");
                filterDevices();
            });
            offlineFilterButton.addEventListener("click", () => {
                document.querySelectorAll(".status-filter").forEach(btn => btn.classList.remove("active"));
                offlineFilterButton.classList.add("active");
                filterDevices();
            });
        })
        .catch((error) => {
            console.error("Error fetching real-time device status:", error);
            detailsContainer.innerHTML = "<p>Failed to load device details.</p>";
        });
}

function showModal(name, ip, location, status, city) {
    document.getElementById("modal-title").textContent = `Details for ${name}`;
    document.getElementById("modal-body").innerHTML = `
            <li><strong>Name:</strong> ${name}</li>
            <li><strong>IP:</strong> ${ip}</li>
            <li><strong>Location:</strong> ${location}</li>
            <li><strong>Status:</strong> ${status}</li>
            <li><strong>City:</strong> ${city}</li>
        `;
    document.getElementById("modal").style.display = "block";
}


// Show/hide button on scroll
window.addEventListener("scroll", () => {
    const btn = document.getElementById("scrollToTopBtn");
    if (document.body.scrollTop > 200 || document.documentElement.scrollTop > 200) {
        btn.style.display = "block";
    } else {
        btn.style.display = "none";
    }
});

// Scroll to top on click
document.getElementById("scrollToTopBtn").addEventListener("click", () => {
    window.scrollTo({ top: 0, behavior: "smooth" });
});


Read above code carefully and below tapable 

this  <label for="city-filter">Filter by Location:</label>
            <select id="city-filter">
                <option value="all">All Cities</option>
            </select>

use this api 
                  http://localhost/api/regions/details/apac   (apac) <<< this is dynamic ok undestant this 
get all cloocatin 
{
  "details": {
    "cameras": [],
    "archivers": [
      {
        "archivername": "Archiver Manila",
        "ip_address": "10.193.132.8",
        "location": "APAC",
        "city": "Quezon",
        "history": [],
        "status": "Online"
      },
      {
        "archivername": "Archiver Taguig City Philippines",
        "ip_address": "10.194.2.190",
        "location": "APAC",
        "city": "Taguig",
        "history": [],
        "status": "Online"
      },
      {
        "archivername": "Archiver Pune-podium flr- India",
        "ip_address": "10.199.8.10",
        "location": "APAC",
        "city": "Pune",
        "history": [],
        "status": "Online"
      },
      {
        "archivername": "Archiver Pune_Tower B",
        "ip_address": "10.199.16.45",
        "location": "APAC",
        "city": "Pune Tower B",
        "history": [],
        "status": "Online"
      },
      {
        "archivername": "Archiver Pune_2nd Flr",
        "ip_address": "10.199.8.12",
        "location": "APAC",
        "city": "Pune",
        "history": [],
        "status": "Online"
      },
      {
        "archivername": "Archiver Server Kuala Lumpur",
        "ip_address": "10.192.5.9",
        "location": "APAC",
        "city": "Kuala Lumpur",
        "history": [],
        "status": "Online"
      }
    ],
    "controllers": [
      {
        "controllername": "IN-PUN-2NDFLR-ISTAR PRO",
        "ip_address": "10.199.13.10",
        "location": "APAC",
        "city": "Pune",
        "history": [],
        "status": "Online"
      },
      {
        "controllername": "IN-PUN-PODIUM-ISTAR PRO-01",
        "ip_address": "10.199.8.20",
        "location": "APAC",
        "city": "Pune",
        "history": [],
        "status": "Online"
      },
      {
        "controllername": "IN-PUN-PODIUM-ISTAR PRO-02",
        "ip_address": "10.199.8.21",
        "location": "APAC",
        "city": "Pune",
        "history": [],
        "status": "Online"
      },
      {
        "controllername": "IN-PUN-PODIUM-ISTAR PRO-03",
        "ip_address": "10.199.10.15",
        "location": "APAC",
        "city": "Pune",
        "history": [],
        "status": "Online"
      },
      {
        "controllername": "IN-PUN-PODIUM-ISTAR ULTRA-4",
        "ip_address": "10.199.8.30",
        "location": "APAC",
        "city": "Pune",
        "history": [],
        "status": "Online"
      },
      {
        "controllername": "IN-PUN-PODIUM-ISTAR ULTRA-5",
        "ip_address": "10.199.10.150",
        "location": "APAC",
        "city": "Pune",
        "history": [],
        "status": "Online"
      },
      {
        "controllername": "IN-PUN-TOWER B-ISTAR ULTRA G2-CONTROLLER 1",
        "ip_address": "10.199.16.40",
        "location": "APAC",
        "city": "Pune Tower B",
        "history": [],
        "status": "Online"
      },
      {
        "controllername": "IN-PUN-TOWER B-ISTAR ULTRA G2-CONTROLLER 2",
        "ip_address": "10.199.16.41",
        "location": "APAC",
        "city": "Pune Tower B",
        "history": [],
        "status": "Online"
      },
      {
        "controllername": "APAC_JP_TOKYO_7TH FLOOR_ISTAR PRO_01",
        "ip_address": "10.192.2.11",
        "location": "APAC",
        "city": "Tokyo",
        "history": [],
        "status": "Online"
      },
      {
        "controllername": "APAC_MY_KUALA LUMPUR_ISTAR ULTRA_CONTROLLER_01",
        "ip_address": "10.192.4.11",
        "location": "APAC",
        "city": "Kuala Lumpur",
        "history": [],
        "status": "Online"
      },
      {
        "controllername": "APAC_PH_MANILA_ 6TH FLOOR_ ISTAR ULTRA SE_01",
        "ip_address": "10.193.133.11",
        "location": "APAC",
        "city": "Quezon",
        "history": [],
        "status": "Online"
      },
      {
        "controllername": "APAC_PH_MANILA_ 7TH FLOOR_ISTAR ULTRA SE_02",
        "ip_address": "10.193.132.140",
        "location": "APAC",
        "city": "Quezon",
        "history": [],
        "status": "Online"
      },
      {
        "controllername": "APAC_PH_MANILA_ISTAR PRO_01",
        "ip_address": "10.194.2.13",
        "location": "APAC",
        "city": "Quezon",
        "history": [],
        "status": "Online"
      }
    ],
    "servers": [
      {
        "servername": "New APACServer  ",
        "ip_address": "10.199.22.61",
        "location": "APAC",
        "city": "Pune",
        "history": [],
        "status": "Online"
      }
    ]
  }
}

        http://localhost/api/regions/details/laca


{
  "details": {
    "cameras": [
      {
        "cameraname": "LACA CR S101 BASEMENT S1 TELECOM WAREHOUSE 07 - 10.64.21.26",
        "ip_address": "10.64.21.26",
        "location": "LACA",
        "city": "Costa Rica ",
        "history": [],
        "status": "Online"
      },
      {
        "cameraname": "LACA CR S102 BASEMENT S1 FIXED ASSETS WAREHOUSE 51 - 10.64.21.28",
        "ip_address": "10.64.21.28",
        "location": "LACA",
        "city": "Costa Rica ",
        "history": [],
        "status": "Online"
      },
      {
        "cameraname": "LACA CR S201 BASEMENT S2 EUC WAREHOUSE 15 - 172.21.132.31",
        "ip_address": "172.21.132.31",
        "location": "LACA",
        "city": "Costa Rica ",
        "history": [],
        "status": "Online"
      },


Read above code carefully and ad   <label for="city-filter">Filter by Location:</label>
            <select id="city-filter">
                <option value="all">All Cities</option>
            </select>

  this in below  and give me update code 


//C:\Users\W0024618\Desktop\NewFrontend\Device Dashboard\summary.js
let deviceUptimeTimers = {};
let deviceDowntimeTimers = {};

// Utility to turn an IP (or any string) into a safe DOM‑ID fragment
function sanitizeId(str) {
    return (str || '').replace(/[^a-zA-Z0-9]/g, '_');
}

function fetchDeviceData() {
    const selectedRegion = document.getElementById('region').value;

    if (selectedRegion === 'All') {
        fetch(`http://localhost/api/regions/all-details`)
            .then(res => res.json())
            .then(allRegionsData => {
                let combinedDetails = { cameras: [], archivers: [], controllers: [], servers: [] };
                Object.values(allRegionsData).forEach(regionData => {
                    if (regionData.details) {
                        ['cameras', 'archivers', 'controllers', 'servers'].forEach(type => {
                            combinedDetails[type].push(...(regionData.details[type] || []));
                        });
                    }
                });
                fetchDeviceHistory(combinedDetails);
            })
            .catch(err => console.error('Error fetching all regions data:', err));
    } else {
        fetch(`http://localhost/api/regions/details/${selectedRegion}`)
            .then(res => res.json())
            .then(regionData => {
                const d = regionData.details;
                const total = (d.cameras?.length || 0) + (d.archivers?.length || 0) + (d.controllers?.length || 0) + (d.servers?.length || 0);
                const online = ([...(d.cameras || []), ...(d.archivers || []), ...(d.controllers || []), ...(d.servers || [])]
                    .filter(dev => dev.status === "Online").length);



                const setWithIcon = (id, iconClass, label, value, colorClass = "") => {
                    const el = document.getElementById(id);
                    if (el) {
                        el.innerHTML = `<i class="${iconClass}"></i> ${label}: <span class="${colorClass}" style="font-weight: 700;">${value}</span>`;
                    }
                };
                setWithIcon("total-devices", "fas fa-network-wired", "Total Devices", total,"text-green");
                setWithIcon("total-online", "fas fa-signal", "Total Online Devices", online, "text-green");
                setWithIcon("total-cameras", "fas fa-video", "Total Cameras", d.cameras?.length || 0,"text-green");
                setWithIcon("total-controllers", "fas fa-microchip", "Total Controllers", d.controllers?.length || 0,"text-green");
                setWithIcon("total-archivers", "fas fa-database", "Total Archivers", d.archivers?.length || 0,"text-green");
                setWithIcon("total-servers", "fas fa-server", "Total Servers", d.servers?.length || 0,"text-green");

                fetchDeviceHistory(d);
            })
            .catch(err => console.error('Error fetching device data:', err));
    }
}

function fetchDeviceHistory(details) {
    fetch(`http://localhost/api/devices/history`)
        .then(res => res.json())
        .then(historyData => {
            populateDeviceTable(details, historyData);
            window.deviceHistoryData = historyData;
        })
        .catch(err => console.error('Error fetching device history:', err));
}

// function populateDeviceTable(details, historyData) {
//     const tbody = document.getElementById('device-table').getElementsByTagName('tbody')[0];
//     tbody.innerHTML = '';
//     let list = [];

//     ['cameras', 'archivers', 'controllers', 'servers'].forEach(type => {
//         details[type]?.forEach(dev => {
//             const ip = dev.ip_address;
//             const safe = sanitizeId(ip);
//             const name = dev[type.slice(0, -1) + 'name'] || 'Unknown';
//             const category = type.slice(0, -1).toUpperCase();
//             const region = dev.location || 'Unknown';
//             const hist = filterHistoryForDisplay(historyData[ip] || [], category);
//             const current = dev.status || (hist.length ? hist[hist.length - 1].status : 'Unknown');
//             const downCount = hist.filter(e => e.status === 'Offline').length;

//             // Only show offline or >15 downtimes
//             if (current === 'Offline' || downCount > 15) {
//                 list.push({ ip, safe, name, category, region, current, hist, downCount });
//             }
//         });
//     });

//     list.sort((a, b) => b.downCount - a.downCount);

//     // compute our two new summary counts:
//     const downtimeOver15Count = list.filter(d => d.downCount > 15).length;
//     const currentlyOfflineCount = list.filter(d => d.current === 'Offline').length;
//     const setIf = (id, txt) => { const el = document.getElementById(id); if (el) el.innerText = txt; };
//     setIf('count-downtime-over-15', `Devices with >15 downtimes: ${downtimeOver15Count}`);
//     setIf('count-currently-offline', `Devices currently Offline: ${currentlyOfflineCount}`);

//     if (!list.length) {
//         const row = tbody.insertRow();
//         const cell = row.insertCell();
//         cell.colSpan = 10;
//         cell.textContent = "No devices found";
//         cell.style.textAlign = "center";
//         cell.style.fontWeight = "bold";
//         updateDisplayedDeviceCount(0);
//         return;
//     }

//     list.forEach((dev, idx) => {
//         const row = tbody.insertRow();

//         //  row.classList.add(dev.current === "Online" ? "online-row" : "offline-row");

//         if (dev.current === 'Offline') {
//   row.classList.add('row-offline');
// } else if (dev.current === 'Online') {
//   row.classList.add('row-online');
// } else {
//   row.classList.add('row-repair');
// }

//         row.style.border = "1px solid black";
//         row.innerHTML = `
//    <td>${idx + 1}</td>
//     <td><span onclick="copyText('${dev.ip}')" style="cursor:pointer; ;">${dev.ip}</span></td>
//     <td><span onclick="copyText('${dev.name}')" style="cursor:pointer; ;">${dev.name}</span></td>
//     <td>${dev.category}</td>
//     <td>${dev.region}</td>
//     <td id="uptime-${dev.safe}">0h/0m/0s</td>
//     <td id="downtime-count-${dev.safe}">${dev.downCount}</td>
//     <td id="downtime-${dev.safe}">0h/0m/0s</td>
//     <td><button  class="history-btn" onclick="openDeviceHistory('${dev.ip}','${dev.name}','${dev.category}')">View History</button></td>
//     <td id="remark-${dev.safe}">Device working properly</td>
// `;
//         row.style.color = dev.current === "Online" ? "#000" : "#000";
       

//         if (dev.current === "Online") {
//             startUptime(dev.ip, dev.hist);
//         } else {
//             startDowntime(dev.ip, dev.hist, dev.category);
//         }
//         updateRemarks(dev.ip, dev.hist, dev.category);
//     });

//     filterData();
// }



function populateDeviceTable(details, historyData) {
    const tbody = document.getElementById('device-table').getElementsByTagName('tbody')[0];
    tbody.innerHTML = '';
    let list = [];
    let locationSet = new Set();

    ['cameras', 'archivers', 'controllers', 'servers'].forEach(type => {
        details[type]?.forEach(dev => {
            const ip = dev.ip_address;
            const safe = sanitizeId(ip);
            const name = dev[type.slice(0, -1) + 'name'] || 'Unknown';
            const category = type.slice(0, -1).toUpperCase();
            const region = dev.location || 'Unknown';
            const hist = filterHistoryForDisplay(historyData[ip] || [], category);
            const current = dev.status || (hist.length ? hist[hist.length - 1].status : 'Unknown');
            const downCount = hist.filter(e => e.status === 'Offline').length;

            locationSet.add(region); // Collect unique locations

            if (current === 'Offline' || downCount > 15) {
                list.push({ ip, safe, name, category, region, current, hist, downCount });
            }
        });
    });

    // Populate the location dropdown
    const locationFilter = document.getElementById('location-filter');
    if (locationFilter) {
        locationFilter.innerHTML = '<option value="All">All Locations</option>';
        [...locationSet].sort().forEach(loc => {
            const opt = document.createElement('option');
            opt.value = loc;
            opt.textContent = loc;
            locationFilter.appendChild(opt);
        });
    }

    list.sort((a, b) => b.downCount - a.downCount);

    const downtimeOver15Count = list.filter(d => d.downCount > 15).length;
    const currentlyOfflineCount = list.filter(d => d.current === 'Offline').length;
    const setIf = (id, txt) => { const el = document.getElementById(id); if (el) el.innerText = txt; };
    setIf('count-downtime-over-15', `Devices with >15 downtimes: ${downtimeOver15Count}`);
    setIf('count-currently-offline', `Devices currently Offline: ${currentlyOfflineCount}`);

    if (!list.length) {
        const row = tbody.insertRow();
        const cell = row.insertCell();
        cell.colSpan = 10;
        cell.textContent = "No devices found";
        cell.style.textAlign = "center";
        cell.style.fontWeight = "bold";
        updateDisplayedDeviceCount(0);
        return;
    }

    window.allDeviceRows = list; // Cache for filtering
    renderFilteredTable();
}


function filterHistoryForDisplay(hist, category) {
    if (category === 'SERVER') return hist.slice(); // show all
    // else: remove any offline entries that resolve within 5 minutes
    const filtered = [];
    let lastOff = null;
    hist.forEach(e => {
        if (e.status === 'Offline') {
            lastOff = e;
        } else if (e.status === 'Online' && lastOff) {
            const diff = (new Date(e.timestamp) - new Date(lastOff.timestamp)) / 1000;
            if (diff >= 300) {
                // keep the offline event and the matching online event
                filtered.push(lastOff, e);
            }
            lastOff = null;
        } else {
            filtered.push(e);
        }
    });
    // If an Offline at end with no Online, and it's >5min ago, keep it
    if (lastOff) {
        const diff = (Date.now() - new Date(lastOff.timestamp)) / 1000;
        if (diff >= 300) filtered.push(lastOff);
    }
    return filtered.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
}

function startUptime(ip, hist) {
    const safe = sanitizeId(ip);
    clearInterval(deviceDowntimeTimers[safe]);
    const lastOn = hist.filter(e => e.status === 'Online').pop();
    if (!lastOn) return;
    const start = new Date(lastOn.timestamp).getTime();
    deviceUptimeTimers[safe] = setInterval(() => {
        const secs = Math.floor((Date.now() - start) / 1000);
        const el = document.getElementById(`uptime-${safe}`);
        if (el) el.innerText = formatDuration(secs);
    }, 1000);
}

function startDowntime(ip, hist, category) {
    const safe = sanitizeId(ip);
    clearInterval(deviceUptimeTimers[safe]);
    const lastOff = hist.filter(e => e.status === 'Offline').pop();
    if (!lastOff) return;
    const start = new Date(lastOff.timestamp).getTime();
    deviceDowntimeTimers[safe] = setInterval(() => {
        const secs = Math.floor((Date.now() - start) / 1000);
        const el = document.getElementById(`downtime-${safe}`);
        if (el) el.innerText = formatDuration(secs);
        updateDowntimeCount(ip, hist, category);
    }, 1000);
}

function updateDowntimeCount(ip, hist, category) {
    const safe = sanitizeId(ip);
    const offs = filterHistoryForDisplay(hist, category).filter(e => e.status === 'Offline');
    const count = offs.length;
    const el = document.getElementById(`downtime-count-${safe}`);
    if (el) el.innerText = count;
    updateRemarks(ip, hist, category);
}

function updateRemarks(ip, hist, category) {
    const safe = sanitizeId(ip);
    const filteredOffs = filterHistoryForDisplay(hist, category).filter(e => e.status === 'Offline');
    const count = filteredOffs.length;
    const lastStatus = hist.length ? hist[hist.length - 1].status : 'Unknown';
    const el = document.getElementById(`remark-${safe}`);
    if (!el) return;

    if (lastStatus === 'Offline') {
        el.innerText = count >= 10 ? "Device is Offline, needs repair." : "Device is Offline.";
    }
    else if (lastStatus === 'Online') {
        if (count >= 10) el.innerText = "Device is Online, needs repair.";
        else if (count > 0) el.innerText = `Device is Online, it had ${count} downtime occurrences.`;
        else el.innerText = "Device is Online.";
    }
    else {
        el.innerText = "Device status unknown.";
    }
    const dc = document.getElementById(`downtime-count-${safe}`);
    if (dc) dc.innerText = count;
}

function formatDuration(seconds) {
    const d = Math.floor(seconds / 86400);
    const h = Math.floor((seconds % 86400) / 3600);
    const m = Math.floor((seconds % 3600) / 60);
    const s = Math.round(seconds % 60);
    const parts = [];
    if (d) parts.push(`${d}d`);
    if (h) parts.push(`${h}h`);
    if (m) parts.push(`${m}m`);
    if (s || !parts.length) parts.push(`${s}s`);
    return parts.join('/');
}

function openDeviceHistory(ip, name, category) {
    if (!window.deviceHistoryData) return console.error("No history loaded");
    const raw = window.deviceHistoryData[ip] || [];
    const hist = filterHistoryForDisplay(raw, category);
    displayDeviceHistory(ip, name, category, hist);
    const modal = document.getElementById('device-history-modal');
    if (modal) modal.style.display = 'block';
}

function calculateDowntimeDuration(ts, hist) {
    const start = new Date(ts).getTime();
    const nextUp = hist.find(e => e.status === 'Online' && new Date(e.timestamp).getTime() > start);
    if (nextUp) return formatDuration((new Date(nextUp.timestamp).getTime() - start) / 1000);
    return formatDuration((Date.now() - start) / 1000);
}

// function displayDeviceHistory(ip, name, category, hist) {
//     const header = document.getElementById('device-history-header');
//     const container = document.getElementById('device-history');
//     if (header) {
//         header.innerHTML = `
//             <h3>Device History</h3>
//             <p><strong>Device Name:</strong> ${name}</p>
//             <p><strong>Device IP:</strong> ${ip}</p>
//             <hr>`;
//     }
//     if (!container) return;
//     container.innerHTML = '';
//     if (!hist.length) {
//         container.innerHTML = '<p>No significant history (all brief outages &lt;5 min).</p>';
//         return;
//     }
//     let html = `
//         <table border="1" style="width:100%; text-align:center; border-collapse:collapse;">
//             <thead><tr>
//                 <th>Sr. No</th><th>Date</th><th>Day</th><th>Time</th><th>Status</th><th>Downtime Duration</th>
//             </tr></thead><tbody>`;
//     let lastOff = null;
//     hist.forEach((e, i) => {
//         const d = new Date(e.timestamp);
//         const date = d.toLocaleDateString();
//         const day = d.toLocaleString('en-US', { weekday: 'long' });
//         const time = d.toLocaleTimeString();
//         let dur = '-';
//         if (e.status === 'Offline') lastOff = e.timestamp;
//         else if (e.status === 'Online' && lastOff) {
//             dur = calculateDowntimeDuration(lastOff, hist);
//             lastOff = null;
//         }
//         html += `
//             <tr>
//                 <td>${i + 1}</td><td>${date}</td><td>${day}</td><td>${time}</td>
//                 <td style="color:${e.status === 'Online' ? '#212529' : '#212529'}">${e.status}</td>
//                 <td>${dur}</td>
//             </tr>`;
//     });
//     html += `</tbody></table>`;
//     container.innerHTML = html;
// }


function displayDeviceHistory(ip, name, category, hist) {
    const header = document.getElementById('device-history-header');
    const container = document.getElementById('device-history');
    
    if (header) {
        header.innerHTML = `
            <h2 style="color: var(--yellow); font-size: 24px; margin-bottom: 10px;">Device History</h2>
            <p><strong>Device Name:</strong> ${name}</p>
            <p><strong>Device IP:</strong> ${ip}</p>
            <hr style="margin: 15px 0; border-color: var(--gray);">`;
    }

    if (!container) return;

    container.innerHTML = '';

    if (!hist.length) {
        container.innerHTML = `<p style="font-style: italic; color: #555;">No significant history (all brief outages &lt; 5 min).</p>`;
        return;
    }

    let html = `
        <div class="history-table-wrapper">
          <table class="history-table">
            <thead>
              <tr>
                <th>Sr. No</th>
                <th>Date</th>
                <th>Day</th>
                <th>Time</th>
                <th>Status</th>
                <th>Downtime Duration</th>
              </tr>
            </thead>
            <tbody>
    `;

    let lastOff = null;
    hist.forEach((e, i) => {
        const d = new Date(e.timestamp);
        const date = d.toLocaleDateString();
        const day = d.toLocaleString('en-US', { weekday: 'long' });
        const time = d.toLocaleTimeString();
        let dur = '-';
        if (e.status === 'Offline') lastOff = e.timestamp;
        else if (e.status === 'Online' && lastOff) {
            dur = calculateDowntimeDuration(lastOff, hist);
            lastOff = null;
        }

        html += `
          <tr>
            <td>${i + 1}</td>
            <td>${date}</td>
            <td>${day}</td>
            <td>${time}</td>
            <td class="${e.status === 'Offline' ? 'status-offline' : 'status-online'}">${e.status}</td>
            <td>${dur}</td>
          </tr>`;
    });

    html += `</tbody></table></div>`;
    container.innerHTML = html;
}


function closeHistoryModal() {
    const modal = document.getElementById('device-history-modal');
    if (modal) modal.style.display = 'none';
}


function filterData() {
    const typeSel = document.getElementById('device-type').value.toUpperCase();
    const remarkSel = document.getElementById('remark-filter').value.toUpperCase();
    const locSel = document.getElementById('location-filter')?.value || "All";
    const rows = document.getElementById('device-table').getElementsByTagName('tbody')[0].rows;
    let count = 0;

    for (let row of rows) {
        const type = row.cells[3].textContent.toUpperCase();
        const remark = row.cells[9].textContent.trim().toUpperCase();
        const location = row.cells[4].textContent.trim();
        const show = (typeSel === 'ALL' || type === typeSel) &&
                     (remarkSel === 'ALL' || remark.includes(remarkSel)) &&
                     (locSel === 'All' || location === locSel);
        row.style.display = show ? '' : 'none';
        if (show) count++;
    }

    updateDisplayedDeviceCount(count);
}


function updateDisplayedDeviceCount(count) {
    const el = document.getElementById('device-count');
    if (el) el.innerText = `Displayed Devices: ${count}`;
}

document.addEventListener("DOMContentLoaded", () => {
    ['region', 'device-type', 'remark-filter'].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.addEventListener('change', id === 'region' ? fetchDeviceData : filterData);
    });
    fetchDeviceData();
});

function exportDeviceTableToExcel() {
    const tbl = document.getElementById("device-table");
    if (!tbl) return;
    const wb = XLSX.utils.table_to_book(tbl, { sheet: "Device Table" });
    XLSX.writeFile(wb, "Device_Table.xlsx");
}

function exportDeviceHistoryToExcel() {
    const histTbl = document.querySelector("#device-history-modal table");
    if (!histTbl) return alert("Please open a device's history first.");
    const wb = XLSX.utils.table_to_book(histTbl, { sheet: "Device History" });
    XLSX.writeFile(wb, "Device_History.xlsx");
}

function copyText(text) {
    navigator.clipboard.writeText(text)
        .then(() => showToast(`Copied: ${text}`))
        .catch(err => console.error("Copy failed: ", err));
}


function showToast(message) {
    const toast = document.getElementById("toast");
    toast.textContent = message;
    toast.className = "toast show";
    setTimeout(() => {
        toast.className = toast.className.replace("show", "");
    }, 2500);
}

function copyToClipboard(elementId) {
    const text = document.getElementById(elementId)?.innerText;
    if (text) {
        navigator.clipboard.writeText(text)
            .then(() => showToast(`Copied: ${text}`))
            .catch(err => console.error("Failed to copy:", err));
    }
}



        
