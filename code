// Updated History.jsx with count matching fixes

// ... (keep all imports same)

export default function History() {
  // ... (keep all existing state and params declarations)

  const detailRows = useMemo(() => {
    if (!data || !pickedDate || !data.details) return [];
    
    const dateStr = format(pickedDate, 'yyyy-MM-dd');
    
    // First get all records for the date
    const dateRecords = data.details.filter(r => {
      const recordDate = format(new Date(r.LocaleMessageTime), 'yyyy-MM-dd');
      return recordDate === dateStr;
    });
    
    // Then filter by location if specified
    const locationFiltered = backendFilterKey 
      ? dateRecords.filter(r => {
          const recordPartition = r.PartitionName2 || r.PartitionNameFriendly;
          if (!recordPartition) return false;
          
          // Normalize comparison
          const normalizedRecord = recordPartition.replace(' City', '').replace('MY.', '').trim();
          const normalizedFilter = backendFilterKey.replace(' City', '').replace('MY.', '').trim();
          
          return normalizedRecord === normalizedFilter;
        })
      : dateRecords;
    
    // Finally deduplicate by PersonGUID and PersonnelType, keeping latest entry
    const uniqueMap = new Map();
    
    locationFiltered
      .filter(r => r.Direction === 'InDirection')
      .sort((a, b) => new Date(b.LocaleMessageTime) - new Date(a.LocaleMessageTime))
      .forEach(row => {
        const key = `${row.PersonGUID}-${row.PersonnelType}`;
        if (!uniqueMap.has(key)) {
          uniqueMap.set(key, row);
        }
      });
    
    return Array.from(uniqueMap.values());
  }, [data, pickedDate, backendFilterKey]);

  // Update partitionRows to ensure counts match detailRows
  const partitionRows = useMemo(() => {
    if (!summaryEntry) return [];
    
    // For single-city view
    if (backendFilterKey && summaryEntry.region) {
      const counts = {
        employee: detailRows.filter(r => r.PersonnelType === 'Employee').length,
        contractor: detailRows.filter(r => r.PersonnelType === 'Contractor').length,
        total: detailRows.length
      };
      
      const feCode = Object.keys(apacPartitionDisplay).find(
        code => apacForwardKey[code] === backendFilterKey || 
               code === backendFilterKey
      );
      
      const display = feCode ? apacPartitionDisplay[feCode] : null;
      
      return [{
        country: display?.country || 'Unknown',
        city: display?.city || backendFilterKey.replace(' City', ''),
        employee: counts.employee,
        contractor: counts.contractor,
        total: counts.total
      }];
    }

    // For global view
    return Object.entries(summaryEntry.partitions || {})
      .filter(([key]) => !backendFilterKey || 
        key.replace(' City', '') === backendFilterKey.replace(' City', ''))
      .map(([key, vals]) => {
        const feCode = Object.entries(apacForwardKey).find(
          ([code, beKey]) => beKey === key || `${beKey} City` === key || code === key
        )?.[0];
        
        const display = feCode ? apacPartitionDisplay[feCode] : 
          Object.entries(apacPartitionDisplay).find(
            ([code]) => code.endsWith(key.replace(' City', ''))
          )?.[1];
        
        // Calculate actual counts from detailRows for this partition
        const partitionDetailRows = detailRows.filter(r => {
          const recordPartition = r.PartitionName2 || r.PartitionNameFriendly;
          if (!recordPartition) return false;
          return recordPartition.replace(' City', '') === key.replace(' City', '');
        });
        
        return {
          country: display?.country || 'Unknown',
          city: display?.city || key.replace(' City', ''),
          employee: partitionDetailRows.filter(r => r.PersonnelType === 'Employee').length,
          contractor: partitionDetailRows.filter(r => r.PersonnelType === 'Contractor').length,
          total: partitionDetailRows.length,
        };
      });
  }, [summaryEntry, backendFilterKey, detailRows]);

  // ... (keep rest of the code same)
}











........................

import React, { useEffect, useState, useMemo } from "react";
import {
  Container, Box, Typography, Button, TextField,
  Paper, TableContainer, Table, TableHead, TableRow, TableCell, TableBody
} from "@mui/material";
import { useParams, useNavigate } from "react-router-dom";

import Header from "../components/Header";
import Footer from "../components/Footer";
import LoadingSpinner from "../components/LoadingSpinner";
import DataTable from "../components/DataTable";

import { fetchLiveSummary } from "../api/occupancy.service";
import { lookupFloor } from "../utils/floorLookup";

export default function PartitionDetailDetails() {
  const { partition } = useParams();
  const navigate = useNavigate();

  const [details, setDetails] = useState([]);
  const [liveCounts, setLiveCounts] = useState({});
  const [loading, setLoading] = useState(true);
  const [lastUpdate, setLastUpdate] = useState("");
  const [search, setSearchTerm] = useState("");
  const [expandedFloor, setExpandedFloor] = useState(null);

  // load once
  useEffect(() => {
    let active = true;
    fetchLiveSummary().then(json => {
      if (!active) return;
      setLiveCounts(json.realtime[partition]?.floors || {});
      
      // Process details to ensure unique entries
      const uniqueDetails = [];
      const seenGuids = new Set();
      
      json.details
        .filter(r => r.PartitionName2 === partition && r.Direction === "InDirection")
        .forEach(r => {
          const guidKey = `${r.PersonGUID}-${r.PersonnelType}`;
          if (!seenGuids.has(guidKey)) {
            seenGuids.add(guidKey);
            uniqueDetails.push({ 
              ...r, 
              floor: lookupFloor(r.PartitionName2, r.Door, r.Direction) 
            });
          }
        });
      
      setDetails(uniqueDetails);
      setLastUpdate(new Date().toLocaleTimeString());
      setLoading(false);
    });
    return () => { active = false };
  }, [partition]);

  // poll
  useEffect(() => {
    const iv = setInterval(async () => {
      const json = await fetchLiveSummary();
      setLiveCounts(json.realtime[partition]?.floors || {});
      
      // Process details to ensure unique entries
      const uniqueDetails = [];
      const seenGuids = new Set();
      
      json.details
        .filter(r => r.PartitionName2 === partition && r.Direction === "InDirection")
        .forEach(r => {
          const guidKey = `${r.PersonGUID}-${r.PersonnelType}`;
          if (!seenGuids.has(guidKey)) {
            seenGuids.add(guidKey);
            uniqueDetails.push({ 
              ...r, 
              floor: lookupFloor(r.PartitionName2, r.Door, r.Direction) 
            });
          }
        });
      
      setDetails(uniqueDetails);
      setLastUpdate(new Date().toLocaleTimeString());
    }, 1000);
    return () => clearInterval(iv);
  }, [partition]);

  // group floors
  const floorMap = useMemo(() => {
    const m = {};
    Object.keys(liveCounts).forEach(f => m[f] = []);
    details.forEach(r => {
      if (!m[r.floor]) m[r.floor] = [];
      m[r.floor].push(r);
    });
    return m;
  }, [details, liveCounts]);

  const displayed = useMemo(() => {
    const term = search.toLowerCase();
    return Object.entries(floorMap)
      .map(([floor, emps]) => {
        const filteredEmps = emps.filter(e =>
          floor.toLowerCase().includes(term) ||
          e.ObjectName1?.toLowerCase().includes(term) ||
          e.EmployeeID?.toString().toLowerCase().includes(term) ||
          e.CardNumber?.toString().toLowerCase().includes(term)
        );
        return [floor, filteredEmps];
      })
      .filter(([, filteredEmps]) => filteredEmps.length > 0);
  }, [floorMap, search]);

  const columns = [
    { field: "EmployeeID", headerName: "Emp ID" },
    { field: "ObjectName1", headerName: "Name" },
    { field: "LocaleMessageTime", headerName: "Swipe Time" },
    { field: "PersonnelType", headerName: "Type" },
    { field: "CardNumber", headerName: "Card" },
    { field: "Door", headerName: "Door" },
  ];

  if (loading) {
    return (
      <>
        <Header />
        <Box sx={{ px: 2, py: 8 }}><LoadingSpinner /></Box>
        <Footer />
      </>
    );
  }

  return (
    <>
      <Header />

      <Box sx={{ pt: 1, pb: 1, background: 'rgba(0,0,0,0.6)' }}>
        <Container disableGutters maxWidth={false}>
          <Box display="flex" alignItems="center" mb={2} sx={{ px: 2 }}>
            <Button size="small" onClick={() => navigate(-1)} sx={{ color: '#FFC107' }}>
              ← Back to Overview
            </Button>
          </Box>

          <Box display="flex" alignItems="center" gap={2} mb={2} sx={{ px: 2 }}>
            <Typography variant="h6" sx={{ color: '#FFC107' }}>
              Floor Details
            </Typography>
            <Typography variant="body2" sx={{ color: '#FFC107' }}>
              Last updated: {lastUpdate}
            </Typography>
            <TextField
              size="small"
              placeholder="Search floor / emp…"
              value={search}
              onChange={e => setSearchTerm(e.target.value)}
              sx={{
                '& .MuiInputBase-input': { color: '#FFC107' },
                '& .MuiOutlinedInput-root fieldset': { borderColor: '#FFC107' }
              }}
            />
          </Box>

          <Box display="flex" flexWrap="wrap" width="100%" sx={{ px: 2 }}>
            {displayed.map(([floor, emps]) => (
              <Box key={floor} sx={{ width: '50%', p: 2 }}>
                <Paper sx={{
                  border: '2px solid #FFC107',
                  p: 2,
                  background: 'rgba(0,0,0,0.4)'
                }}>
                  <Typography variant="subtitle1" fontWeight={600} gutterBottom sx={{ color: '#FFC107' }}>
                    {floor} (Total {emps.length})
                  </Typography>

                  <TableContainer component={Paper} variant="outlined" sx={{ mb: 1, background: 'rgba(0,0,0,0.4)' }}>
                    <Table size="small">
                      <TableHead>
                        <TableRow sx={{ bgcolor: '#000' }}>
                          {["Emp ID", "Name", "Swipe Time", "Type", "Card", "Door"].map(h => (
                            <TableCell key={h} sx={{ color: '#FFC107', border: '1px solid #FFC107', fontWeight: 'bold' }}>
                              {h}
                            </TableCell>
                          ))}
                        </TableRow>
                      </TableHead>
                      <TableBody>
                        {emps.slice(0, 10).map((r, i) => (
                          <TableRow key={i}>
                            <TableCell sx={{ color: '#fff', border: '1px solid #FFC107' }}>{r.EmployeeID}</TableCell>
                            <TableCell sx={{ color: '#fff', border: '1px solid #FFC107' }}>{r.ObjectName1}</TableCell>
                            <TableCell sx={{ color: '#fff', border: '1px solid #FFC107' }}>
                              {new Date(r.LocaleMessageTime).toLocaleTimeString()}
                            </TableCell>
                            <TableCell sx={{ color: '#fff', border: '1px solid #FFC107' }}>{r.PersonnelType}</TableCell>
                            <TableCell sx={{ color: '#fff', border: '1px solid #FFC107' }}>{r.CardNumber}</TableCell>
                            <TableCell sx={{ color: '#fff', border: '1px solid #FFC107' }}>{r.Door}</TableCell>
                          </TableRow>
                        ))}
                      </TableBody>
                    </Table>
                  </TableContainer>

                  <Button size="small"
                    onClick={() => setExpandedFloor(f => f === floor ? null : floor)}
                    sx={{ color: '#FFC107' }}
                  >
                    {expandedFloor === floor ? 'Hide' : 'See more…'}
                  </Button>
                </Paper>
              </Box>
            ))}
          </Box>

          {expandedFloor && (
            <Box sx={{ px: 2, mt: 2 }}>
              <Typography variant="h6" sx={{ color: '#FFC107' }} gutterBottom>
                {expandedFloor} — All Entries (Total {floorMap[expandedFloor]?.length || 0})
              </Typography>
              <DataTable
                columns={columns}
                rows={floorMap[expandedFloor]?.map(r => ({
                  ...r,
                  LocaleMessageTime: new Date(r.LocaleMessageTime).toLocaleTimeString()
                })) || []}
              />
            </Box>
          )}
        </Container>
      </Box>

      <Footer />
    </>
  );
}