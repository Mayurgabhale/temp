// src/api/occupancy.service.js

export async function fetchHistory(location) {
  // Complete mapping of all possible frontend and backend partition names
  const codeMap = {
    // Frontend codes to backend keys
    'IN.Pune': 'Pune',
    'MY.Kuala Lumpur': 'MY.Kuala Lumpur',
    'PH.Quezon': 'Quezon City',
    'PH.Taguig': 'Taguig City',
    'JP.Tokyo': 'JP.Tokyo',
    // Direct backend keys
    'Pune': 'Pune',
    'Quezon City': 'Quezon City',
    'Taguig City': 'Taguig City',
    'Kuala Lumpur': 'MY.Kuala Lumpur',
    'MY.Kuala Lumpur': 'MY.Kuala Lumpur',
    'JP.Tokyo': 'JP.Tokyo'
  };

  const key = location ? codeMap[location] || location : 'global';

  // Return cached if available
  if (cache.history.has(key)) {
    return cache.history.get(key);
  }

  // Build URL: global vs. per-partition
  const url = key === 'global'
    ? `${BASE}/api/occupancy/history`
    : `${BASE}/api/occupancy/history/${encodeURIComponent(key)}`;

  const res = await fetch(url);
  if (!res.ok) {
    throw new Error(`History fetch failed: ${res.status}`);
  }
  const json = await res.json();
  cache.history.set(key, json);
  return json;
}










// APAC display mapping (country + city) by front-end code
const apacPartitionDisplay = {
  'IN.Pune': { country: 'India', city: 'Pune' },
  'MY.Kuala Lumpur': { country: 'Malaysia', city: 'Kuala Lumpur' },
  'PH.Quezon': { country: 'Philippines', city: 'Quezon City' },
  'PH.Taguig': { country: 'Philippines', city: 'Taguig' },
  'JP.Tokyo': { country: 'Japan', city: 'Tokyo' },
};

// Forward map: front-end code → backend key
const apacForwardKey = {
  'IN.Pune': 'Pune',
  'MY.Kuala Lumpur': 'MY.Kuala Lumpur',
  'PH.Quezon': 'Quezon City',
  'PH.Taguig': 'Taguig City',
  'JP.Tokyo': 'JP.Tokyo'
};

// Reverse map: backend key → front-end code
const apacReverseKey = {
  'Pune': 'IN.Pune',
  'Quezon City': 'PH.Quezon',
  'Taguig City': 'PH.Taguig',
  'MY.Kuala Lumpur': 'MY.Kuala Lumpur',
  'JP.Tokyo': 'JP.Tokyo'
};









const partitionRows = useMemo(() => {
  if (!summaryEntry) return [];

  return Object.entries(summaryEntry.partitions)
    .filter(([key]) => {
      if (!backendFilterKey) return true;
      
      // Handle all possible backend key variations
      if (backendFilterKey === 'Taguig City' && key === 'Taguig City') return true;
      if (backendFilterKey === 'Quezon City' && key === 'Quezon City') return true;
      if (backendFilterKey === 'MY.Kuala Lumpur' && key === 'MY.Kuala Lumpur') return true;
      if (backendFilterKey === 'JP.Tokyo' && key === 'JP.Tokyo') return true;
      if (backendFilterKey === 'Pune' && key === 'Pune') return true;
      
      return false;
    })
    .map(([key, vals]) => {
      const feCode = apacReverseKey[key];
      const display = feCode && apacPartitionDisplay[feCode];

      return {
        country: display ? display.country : key,
        city: display ? display.city : key,
        employee: vals.Employee ?? 0,
        contractor: vals.Contractor ?? 0,
        total: vals.total ?? 0,
      };
    });
}, [summaryEntry, backendFilterKey]);

const detailRows = useMemo(() => {
  if (!data || !pickedDate) return [];
  const dateStr = format(pickedDate, 'yyyy-MM-dd');
  return data.details
    .filter(r => format(new Date(r.LocaleMessageTime), 'yyyy-MM-dd') === dateStr)
    .filter(r => {
      if (!backendFilterKey) return true;
      
      // Handle all possible backend key variations
      if (backendFilterKey === 'Taguig City' && r.PartitionName2 === 'Taguig City') return true;
      if (backendFilterKey === 'Quezon City' && r.PartitionName2 === 'Quezon City') return true;
      if (backendFilterKey === 'MY.Kuala Lumpur' && r.PartitionName2 === 'MY.Kuala Lumpur') return true;
      if (backendFilterKey === 'JP.Tokyo' && r.PartitionName2 === 'JP.Tokyo') return true;
      if (backendFilterKey === 'Pune' && r.PartitionName2 === 'Pune') return true;
      
      return false;
    })
    .filter(r => r.Direction === 'InDirection')
    .reduce((unique, row) => {
      const keyGUID = `${row.PersonGUID}-${row.PersonnelType}`;
      if (!unique._seen.has(keyGUID)) {
        unique._seen.add(keyGUID);
        unique.rows.push(row);
      }
      return unique;
    }, { _seen: new Set(), rows: [] })
    .rows;
}, [data, pickedDate, backendFilterKey]);












