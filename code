.filter(([key]) => {
  if (!decodedPartition) return true;

  // Find FE code (e.g. 'IN.Pune') for current summary partition key (e.g. 'IN.Pune')
  const currentFECode = apacReverseKey[key];
  return currentFECode === decodedPartition;
})










const partitionRows = useMemo(() => {
  if (!summaryEntry) return [];

  return Object.entries(summaryEntry.partitions)
    .filter(([key]) => {
      if (!decodedPartition) return true;
      const currentFECode = apacReverseKey[key];
      return currentFECode === decodedPartition;
    })
    .map(([key, vals]) => {
      const feCode = apacReverseKey[key];
      const display = feCode && apacPartitionDisplay[feCode];
      return {
        country: display ? display.country : key,
        city: display ? display.city : key,
        employee: vals.Employee ?? 0,
        contractor: vals.Contractor ?? 0,
        total: vals.total ?? 0,
      };
    });
}, [summaryEntry, decodedPartition]);










const detailRows = useMemo(() => {
  if (!data || !pickedDate) return [];
  const dateStr = format(pickedDate, 'yyyy-MM-dd');
  return data.details
    .filter(r => format(new Date(r.LocaleMessageTime), 'yyyy-MM-dd') === dateStr)
    .filter(r => {
      if (!decodedPartition) return true;
      const feCode = apacReverseKey[r.PartitionName2];
      return feCode === decodedPartition;
    })
    .filter(r => r.Direction === 'InDirection')
    .reduce((unique, row) => {
      const keyGUID = `${row.PersonGUID}-${row.PersonnelType}`;
      if (!unique._seen.has(keyGUID)) {
        unique._seen.add(keyGUID);
        unique.rows.push(row);
      }
      return unique;
    }, { _seen: new Set(), rows: [] })
    .rows;
}, [data, pickedDate, decodedPartition]);
