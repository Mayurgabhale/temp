
 <label for="region">Select Region:</label>
            <select id="region" onchange="fetchDeviceData()">
                <option value="global" selected>Global</option>
                <option value="apac">APAC</option>
                <option value="emea">EMEA</option>
                <option value="laca">LACA</option>
                <option value="namer">NAMER</option>
            </select>

            <label for="device-type">Filter by Device Type:</label>
            <select id="device-type" onchange="filterData()">
                <option value="ALL">All</option>
                <option value="CONTROLLER">Controller</option>
                <option value="ARCHIVER">Archiver</option>
                <option value="CAMERA">Camera</option>
                <option value="SERVER">Server</option>
            </select>

            <label for="remark-filter">Filter by Remark:</label>
            <select id="remark-filter" onchange="filterData()">
                <option value="ALL">All</option>
                <option value="Device needs repair">Device needs repair</option>
                <option value="Device is Online">Device is Online</option>
                <option value="Device is Offline">Device is Offline</option>
            </select>

        

            
            <label for="cityFilter">City:</label>
                <select id="cityFilter" id="remark-filter">
                    <option value="all">All Cities</option>
                </select>



in this  <label for="remark-filter">Filter by Remark:</label> and  <label for="device-type">Filter by Device Type:</label>
this is not filter out means i select   <option value="Device is Online">Device is Online</option> this then in table i got only online devices on like tat both other is work proprly but this tow are not work
so red all code carefully and give me update code

let deviceUptimeTimers = {};
let deviceDowntimeTimers = {};

// Utility to turn an IP (or any string) into a safe DOM-ID fragment
function sanitizeId(str) {
  return (str || '').replace(/[^a-zA-Z0-9]/g, '_');
}

function fetchDeviceData() {
  const region = document.getElementById('region').value;
  fetch(`http://localhost/api/regions/details/${region}`)
    .then(r => r.json())
    .then(d => fetchDeviceHistory(d.details))
    .catch(console.error);
}

function fetchDeviceHistory(details) {
  fetch(`http://localhost/api/devices/history`)
    .then(r => r.json())
    .then(historyData => {
      populateDeviceTable(details, historyData);
      window.deviceHistoryData = historyData;
    })
    .catch(console.error);
}

function populateDeviceTable(details, historyData) {
  const Devices = [];
  const tbody = document.querySelector('#device-table tbody');
  tbody.innerHTML = '';

  const devices = [];
  ['cameras','archivers','controllers','servers'].forEach(type => {
    (details[type] || []).forEach(dev => {
      const ip        = dev.ip_address;
      const safe      = sanitizeId(ip);
      const name      = dev[type.slice(0,-1) + 'name'] || 'Unknown';
      const category  = type.slice(0,-1).toUpperCase();
      const rawHist   = historyData[ip] || [];
      const city      = dev.city || 'Unknown';
      const hist      = filterHistoryForDisplay(rawHist, category);
      const lastRaw   = rawHist[rawHist.length-1]?.status || 'Unknown';
      // if last raw Offline but <5min, treat Online
      let status = lastRaw;
      if (lastRaw === 'Offline' && ((Date.now() - new Date(rawHist[rawHist.length-1].timestamp)) / 1000) < 300) {
        status = 'Online';
      }
      const downCount = hist.filter(e => e.status === 'Offline').length;

      devices.push({ ip, safe, name, category, rawHist, hist, status, downCount,city  });
    });
  });

  // sort by ongoing ≥5min offline first, then by downCount desc
  devices.sort((a,b) => {
    const now = Date.now();
    const aLast = a.hist[a.hist.length-1], bLast = b.hist[b.hist.length-1];
    const aOff  = aLast?.status==='Offline' ? (now-new Date(aLast.timestamp))/1000 : 0;
    const bOff  = bLast?.status==='Offline' ? (now-new Date(bLast.timestamp))/1000 : 0;
    if ((aOff>=300) !== (bOff>=300)) return aOff>=300 ? -1 : 1;
    return b.downCount - a.downCount;
  });

  devices.forEach((d,i) => {
    const row = tbody.insertRow();

    // row.classList.add(d.status==='Online' ? 'status-online' : 'status-offline');

if (d.status === 'Offline') {
  row.classList.add('row-offline');
} else if (d.status === 'Online') {
  row.classList.add('row-online');
} else {
  // Optional: handle unknown or other cases
  row.classList.add('row-repair');
}


//     row.innerHTML = `
// <td>${i+1}</td>
// <td><span id="ip-${d.safe}" class="copy-text" onclick="copyToClipboard('ip-${d.safe}')">${d.ip}</span></td>
// <td><span id="name-${d.safe}" class="copy-text" onclick="copyToClipboard('name-${d.safe}')">${d.name}</span></td>
// <td>${d.category}</td>
// <td id="uptime-${d.safe}">0h/0m/0s</td>
// <td id="downtime-count-${d.safe}">${d.downCount}</td>
// <td id="downtime-${d.safe}">0h/0m/0s</td>
// <td><button class="history-btn" onclick="openDeviceHistory('${d.ip}','${d.name}','${d.category}')">View History</button></td>
// <td id="remark-${d.safe}">–</td>
// `;


row.innerHTML = `
<td>${i+1}</td>
<td><span id="ip-${d.safe}" class="copy-text" onclick="copyToClipboard('ip-${d.safe}')">${d.ip}</span></td>
<td><span id="name-${d.safe}" class="copy-text" onclick="copyToClipboard('name-${d.safe}')">${d.name}</span></td>
<td>${d.category}</td>
<td>${d.city}</td>
<td id="uptime-${d.safe}">0h/0m/0s</td>
<td id="downtime-count-${d.safe}">${d.downCount}</td>
<td id="downtime-${d.safe}">0h/0m/0s</td>
<td><button class="history-btn" onclick="openDeviceHistory('${d.ip}','${d.name}','${d.category}')">View History</button></td>
<td id="remark-${d.safe}" data-city="${d.city}">–</td>
`;


    if (d.status === 'Online') startUptime(d.ip, d.hist);
    else startDowntime(d.ip, d.hist);

    updateRemarks(d.ip, d.hist, d.status, d.downCount);
  });



  // ✅ Add this block AFTER `devices.forEach(...)` inside populateDeviceTable
  const cityFilter = document.getElementById('cityFilter');
if (cityFilter) {
  const uniqueCities = [...new Set(devices.map(dev => dev.city).filter(Boolean))].sort();
  cityFilter.innerHTML = '<option value="all">All Cities</option>';
  uniqueCities.forEach(city => {
    const option = document.createElement('option');
    option.value = city;
    option.textContent = city;
    cityFilter.appendChild(option);
  });
}

  filterData();


}

function filterHistoryForDisplay(hist, category) {
  if (category === 'SERVER') return hist.slice();

  const out = [];
  
  let lastOff = null;
  hist.forEach(e => {
    if (e.status === 'Offline') lastOff = e;
    else if (e.status === 'Online' && lastOff) {
      const diff = (new Date(e.timestamp) - new Date(lastOff.timestamp)) / 1000;
      if (diff >= 300) out.push(lastOff, e);
      lastOff = null;
    }
  });

  if (lastOff) {

    const diff = (Date.now() - new Date(lastOff.timestamp)) / 1000;
    if (diff >= 300) out.push(lastOff);
  }
  
  return out.sort((a,b) => new Date(a.timestamp) - new Date(b.timestamp));
}

function startUptime(ip, hist) {
  const safe = sanitizeId(ip);
  clearInterval(deviceDowntimeTimers[safe]);
  const on = hist.filter(e => e.status==='Online').pop();
  if (!on) return;
  const t0 = new Date(on.timestamp).getTime();
  deviceUptimeTimers[safe] = setInterval(() => {
    document.getElementById(`uptime-${safe}`).innerText = formatDuration(Math.floor((Date.now()-t0)/1000));
  }, 1000);
}

function startDowntime(ip, hist) {
  const safe = sanitizeId(ip);
  clearInterval(deviceUptimeTimers[safe]);
  const off = hist.filter(e => e.status==='Offline').pop();
  if (!off) return;
  const t0 = new Date(off.timestamp).getTime();
  deviceDowntimeTimers[safe] = setInterval(() => {
    const secs = Math.floor((Date.now()-t0)/1000);
    document.getElementById(`downtime-${safe}`).innerText = formatDuration(secs);
    document.getElementById(`downtime-count-${safe}`).innerText = hist.filter(e => e.status==='Offline').length;
    updateRemarks(ip, hist, null, null);
  }, 1000);
}

function updateRemarks(ip, hist, forcedStatus, forcedCount) {
  const safe = sanitizeId(ip);
  // Determine status
  let status = forcedStatus;
  if (!status) {
    const last = hist[hist.length-1]?.status || 'Unknown';
    status = last==='Offline' && ((Date.now()-new Date(hist[hist.length-1].timestamp))/1000)<300
      ? 'Online' : last;
  }
  const count = forcedCount ?? hist.filter(e => e.status==='Offline').length;
  const el = document.getElementById(`remark-${safe}`);
  if (!el) return;
  if (status === 'Offline') {
    el.innerText = count>0 ? 'Device is Offline, needs check.' : 'Device is Offline.';
  } else if (status === 'Online') {
    el.innerText = count>0
      ? `Device is Online, had ${count} downtime events ≥5 min.`
      : 'Device is Online.';
  } else {
    el.innerText = 'Device status unknown.';
  }
}

function formatDuration(sec) {
  const d = Math.floor(sec/86400), h = Math.floor((sec%86400)/3600),
        m = Math.floor((sec%3600)/60), s = Math.round(sec%60);
  const parts = [];
  if (d) parts.push(`${d}d`);
  if (h) parts.push(`${h}h`);
  if (m) parts.push(`${m}m`);
  if (s||!parts.length) parts.push(`${s}s`);
  return parts.join('/');
}

function openDeviceHistory(ip, name, category) {
  const raw = window.deviceHistoryData[ip] || [];
  const hist = filterHistoryForDisplay(raw, category);
  displayDeviceHistory(ip, name, category, hist);
  document.getElementById('device-history-modal').style.display = 'block';
}



function displayDeviceHistory(ip, name, category, hist) {
  const header = document.getElementById('device-history-header');
  const container = document.getElementById('device-history');
  header.innerHTML = `
    <h2 style="color: var(--yellow); font-size: 24px;">${name} <span style="font-size:16px;">(${ip})</span></h2>
    <hr style="margin: 10px 0; border-color: var(--gray);">
  `;

  if (!hist.length) {
    container.innerHTML = `<p style="font-style: italic; color: #777;">No downtime ≥5 min in history.</p>`;
    return;
  }

  let html = `
    <div class="scrollable-history-table">
      <table class="history-table">
        <thead>
          <tr>
            <th>Sr.No</th><th>Date</th><th>Day</th><th>Time</th><th>Status</th><th>Duration</th>
          </tr>
        </thead>
        <tbody>
  `;

  let idx = 1;
  let lastOff = null;

  hist.forEach(e => {
    const t = new Date(e.timestamp);
    const date = t.toLocaleDateString();
    const day = t.toLocaleString('en-US', { weekday: 'long' });
    const time = t.toLocaleTimeString();
    let dur = '-';

    if (e.status === 'Offline') {
      if (!lastOff) {
        lastOff = e.timestamp;
        html += `
          <tr>
            <td>${idx++}</td><td>${date}</td><td>${day}</td><td>${time}</td>
            <td class="status-offline">${e.status}</td><td>${dur}</td>
          </tr>`;
      }
    } else if (e.status === 'Online') {
      if (lastOff) {
        const diff = (new Date(e.timestamp) - new Date(lastOff)) / 1000;
        dur = formatDuration(diff);
        const offTime = new Date(lastOff);
        const offDate = offTime.toLocaleDateString();
        const offDay = offTime.toLocaleString('en-US', { weekday: 'long' });
        const offClock = offTime.toLocaleTimeString();

        html += `
          <tr>
            <td>${idx++}</td><td>${offDate}</td><td>${offDay}</td><td>${offClock}</td>
            <td class="status-offline">Offline</td><td>${dur}</td>
          </tr>
          <tr>
            <td>${idx++}</td><td>${date}</td><td>${day}</td><td>${time}</td>
            <td class="status-online">${e.status}</td><td>${formatDuration(0)}</td>
          </tr>`;

        lastOff = null;
      } else {
        html += `
          <tr>
            <td>${idx++}</td><td>${date}</td><td>${day}</td><td>${time}</td>
            <td class="status-online">${e.status}</td><td>${dur}</td>
          </tr>`;
      }
    }
  });

  if (lastOff) {
    const t = new Date(lastOff);
    const date = t.toLocaleDateString();
    const day = t.toLocaleString('en-US', { weekday: 'long' });
    const time = t.toLocaleTimeString();
    const now = Date.now();
    const dur = formatDuration((now - new Date(lastOff)) / 1000);

    html += `
      <tr>
        <td>${idx++}</td><td>${date}</td><td>${day}</td><td>${time}</td>
        <td class="status-offline">Offline</td><td>${dur}</td>
      </tr>`;
  }

  html += `</tbody></table></div>`;
  container.innerHTML = html;
}




function closeHistoryModal() {
  document.getElementById('device-history-modal').style.display = 'none';
}

function exportDeviceTableToExcel() {
    const table = document.getElementById("device-table");
    const workbook = XLSX.utils.table_to_book(table, { sheet: "Device Table" });
    XLSX.writeFile(workbook, "Device_Table.xlsx");
}


function exportDeviceHistoryToExcel() {
    const historyTable = document.querySelector("#device-history-modal table");
    if (!historyTable) {
        alert("Please open a device's history first.");
        return;
    }
    const workbook = XLSX.utils.table_to_book(historyTable, { sheet: "Device History" });
    XLSX.writeFile(workbook, "Device_History.xlsx");
}



function filterData() {
  const typeSel     = document.getElementById('device-type').value.toUpperCase();
  const remarkSel   = document.getElementById('remark-filter').value.toUpperCase();
  const citySel     = document.getElementById('cityFilter')?.value.toUpperCase() || "ALL";
  const searchTxt   = document.getElementById('search-input').value.toUpperCase();

  document.querySelectorAll('#device-table tbody tr').forEach(r => {
    const ip     = r.cells[1].textContent.toUpperCase();
    const name   = r.cells[2].textContent.toUpperCase();
    const type   = r.cells[3].textContent.toUpperCase();
    const city   = r.cells[8]?.dataset?.city?.toUpperCase() || r.cells[4].textContent.toUpperCase(); // fallback
    const remark = r.cells[8]?.textContent.toUpperCase();

    const matchesType   = (typeSel === 'ALL' || type === typeSel);
    const matchesRemark = (remarkSel === 'ALL' || remark.includes(remarkSel));
    const matchesCity   = (citySel === 'ALL' || city === citySel);
    const matchesSearch = (ip.includes(searchTxt) || name.includes(searchTxt));

    r.style.display = matchesType && matchesRemark && matchesCity && matchesSearch ? '' : 'none';
  });
}

function copyToClipboard(id) {
  const t = document.getElementById(id)?.innerText;
  if (t) navigator.clipboard.writeText(t);
}



document.addEventListener('DOMContentLoaded', () => {
  ['region', 'device-type', 'remark-filter'].forEach(id => {
    document.getElementById(id)?.addEventListener('change', id === 'region' ? fetchDeviceData : filterData);
  });

  document.getElementById('search-input')?.addEventListener('input', filterData);

  // ✅ Add cityFilter event
  document.getElementById('cityFilter')?.addEventListener('change', filterData);

  fetchDeviceData();
});


function showToast(message) {
    const toast = document.getElementById("toast");
    toast.textContent = message;
    toast.className = "toast show";
    setTimeout(() => {
        toast.className = toast.className.replace("show", "");
    }, 2500);
}

function copyToClipboard(elementId) {
    const text = document.getElementById(elementId)?.innerText;
    if (text) {
        navigator.clipboard.writeText(text)
            .then(() => showToast(`Copied: ${text}`))
            .catch(err => console.error("Failed to copy:", err));
    }
}

