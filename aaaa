useEffect(() => {
  setLoading(true);
  fetchHistory(decodedPartition)
    .then(json => {
      setData(json);
      console.log('Raw data from API:', json);
      console.log('Summary records count:', json.summaryByDate?.[0]?.partitions);
      console.log('Detail records count:', json.details?.length);
    })
    .finally(() => setLoading(false));
}, [decodedPartition]);






const detailRows = useMemo(() => {
  if (!data || !pickedDate || !data.details) return [];
  
  const dateStr = format(pickedDate, 'yyyy-MM-dd');
  
  // Get all records for the selected date
  const dateFiltered = data.details.filter(r => {
    const recordDate = format(new Date(r.LocaleMessageTime), 'yyyy-MM-dd');
    return recordDate === dateStr;
  });

  // Group by PersonGUID and keep only the latest record per person
  const latestByPerson = dateFiltered.reduce((acc, row) => {
    const key = row.PersonGUID;
    if (!acc[key] || new Date(row.LocaleMessageTime) > new Date(acc[key].LocaleMessageTime)) {
      acc[key] = row;
    }
    return acc;
  }, {});

  // Convert to array and apply location filter
  let result = Object.values(latestByPerson);
  
  if (backendFilterKey) {
    result = result.filter(row => {
      const recordPartition = (row.PartitionName2 || row.PartitionNameFriendly || '');
      return recordPartition.replace(' City', '') === backendFilterKey.replace(' City', '');
    });
  }

  // Now apply the InDirection filter (same as backend)
  result = result.filter(row => row.Direction === 'InDirection');

  // Debug logs
  console.log('Processing details:');
  console.log('- Total for date:', dateFiltered.length);
  console.log('- Unique people:', Object.keys(latestByPerson).length);
  console.log('- After location filter:', result.length);
  
  return result;
}, [data, pickedDate, backendFilterKey]);









const partitionRows = useMemo(() => {
  if (!summaryEntry) return [];

  // Debug log to see what the summary contains
  console.log('Summary entry data:', summaryEntry);

  // Handle single-city response
  if (backendFilterKey && summaryEntry.region) {
    const feCode = Object.keys(apacPartitionDisplay).find(
      code => apacForwardKey[code] === backendFilterKey || code === backendFilterKey
    );
    
    const display = feCode ? apacPartitionDisplay[feCode] : null;
    
    return [{
      country: display?.country || 'Unknown',
      city: display?.city || backendFilterKey.replace(' City', ''),
      employee: summaryEntry.region.Employee ?? 0,
      contractor: summaryEntry.region.Contractor ?? 0,
      total: summaryEntry.region.total ?? 0
    }];
  }

  // Handle global view
  const partitions = Object.entries(summaryEntry.partitions || {})
    .filter(([key]) => !backendFilterKey || 
      key.replace(' City', '') === backendFilterKey.replace(' City', ''))
    .map(([key, vals]) => {
      const feCode = Object.entries(apacForwardKey).find(
        ([code, beKey]) => beKey === key || `${beKey} City` === key || code === key
      )?.[0];
      
      const display = feCode ? apacPartitionDisplay[feCode] : 
        Object.entries(apacPartitionDisplay).find(
          ([code]) => code.endsWith(key.replace(' City', ''))
        )?.[1];
      
      return {
        country: display?.country || 'Unknown',
        city: display?.city || key.replace(' City', ''),
        employee: vals.Employee ?? vals.EmployeeCount ?? 0,
        contractor: vals.Contractor ?? vals.ContractorCount ?? 0,
        total: vals.total ?? 0,
      };
    });

  console.log('Processed partitions:', partitions);
  return partitions;
}, [summaryEntry, backendFilterKey]);










// Verification logic
useEffect(() => {
  if (!partitionRows.length || !detailRows.length) return;
  
  const summaryTotal = partitionRows.reduce((sum, r) => sum + r.total, 0);
  const detailTotal = detailRows.length;
  
  if (summaryTotal !== detailTotal) {
    console.warn(`Count mismatch! Summary: ${summaryTotal}, Details: ${detailTotal}`);
    
    // Find GUIDs in summary but missing in details
    const summaryGuids = new Set(data.details
      .filter(r => {
        const recordDate = format(new Date(r.LocaleMessageTime), 'yyyy-MM-dd');
        return recordDate === format(pickedDate, 'yyyy-MM-dd');
      })
      .filter(r => r.Direction === 'InDirection')
      .map(r => r.PersonGUID));
    
    const detailGuids = new Set(detailRows.map(r => r.PersonGUID));
    
    const missingInDetails = [...summaryGuids].filter(x => !detailGuids.has(x));
    console.log('Records in summary missing from details:', missingInDetails);
  }
}, [partitionRows, detailRows, data, pickedDate]);
